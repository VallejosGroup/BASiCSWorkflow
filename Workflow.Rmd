---
title: "BASiCS workflow: a step-by-step analysis of expression variability using single cell RNA sequencing data"
author: 
  - name: Nils Eling
    affiliation: 
    - &EBI European Molecular Biology Laboratory, European Bioinformatics 
      Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
    - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
      Li Ka Shing Centre, Cambridge, CB2 0RE, UK
    email: eling@ebi.ac.uk
  - name: Alan O'Callaghan
    affiliation: 
    - &MRC MRC Human Genetics Unit, Institute of Genetics \& Molecular Medicine, 
      University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, 
      EH4 2XU, UK
  - name: John C. Marioni
    affiliation: 
    - *EBI
    - *CRUK
  - name: Catalina A. Vallejos
    affiliation: 
    - *MRC 
    - The Alan Turing Institute, British Library, 96 Euston Road, London, 
      NW1 2DB, UK
    email: catalina.vallejos@igmm.ed.ac.uk
abstract: |
  Cell-to-cell gene expression variability is an inherent feature of complex 
  biological systems. Single-cell RNA sequencing can be used to quantify this 
  heterogeneity, but it is prone to strong technical noise. Here, we describe a 
  step-by-step computational workflow which uses the BASiCS Bioconductor package 
  to robustly quantify expression variability within and between known cell 
  populations (such as experimental conditions or cell types). BASiCS provides 
  an integrated framework for data normalisation, technical noise quantification
  and downstream analyses, whilst propagating statistical uncertainty across 
  these steps. Within a single seemingly homogeneous cell population, BASiCS 
  can be used identify highly variable genes that drive the heterogeneity 
  within the population as well as lowly variable genes that might exhibit 
  housekeeping-like behavior. BASiCS also provides a probabilistic rule to
  identify changes in expression variability between cell populations, while 
  avoiding confounding effects related to differences in technical noise or in 
  overall abundance. Using two publicly available datasets, we guide users 
  through a complete pipeline which includes preliminary steps for quality 
  control and data exploration using the scater and scran Bioconductor packages. 
  Data for the first case study was generated using the Fluidigm\@ C1 system, in 
  which extrinsic spike-in RNA molecules were added in order to quantify 
  technical noise. The second dataset was generated using a droplet-based 
  system, for which spike-in RNA is not available. This analysis provides an 
  example, in which differential variability testing reveals insights regarding 
  a possible early cell fate commitment process. The workflow is accompanied by 
  a Docker image which ensures the reproducibility of our results. 
keywords: Single-cell RNA sequencing, expression variability, 
  transcriptional noise, differential expression testing
bibliography: Workflow.bib
urlcolor: Orange
output:
  BiocWorkflowTools::f1000_article: default
  BiocStyle::html_document: default
---


```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
on.bioc <- FALSE
library("knitr")
library("ggplot2")
# Use fig.width = 7 for html and fig.width = 6 for pdf
fig.width <- ifelse(on.bioc, 7, 6)
knitr::opts_chunk$set(
  cache = TRUE, warning = FALSE, message = FALSE, error = FALSE,
  cache.path = "cache/", fig.path = "figure/", fig.width = fig.width
)
```


# Introduction

<!--- scRNA-Seq and the different types of heterogeneity ---> 
Single-cell RNA-sequencing (scRNA-seq) enables the study of genome-wide 
transcriptional heterogeneity in cell populations that remains otherwise 
undetected in bulk experiments [@Stegle2015; @Prakadan2017; @Patange2018]. 
Applications of scRNA-seq range from characterising cell types in immunity 
[@Lonnberg2017;  @Villani2017; @Zheng2017] and development [@Ibarra-Soria2018; 
@Wagner2018; @Pijuan-Sala2019] to dissecting the mechanisms for cell fate 
commitment [@Goolam2016; @Ohnishi2014]. 
Transcriptional heterogeneity within a cell population can relate to different 
underlying sources.
On the broadest level, this heterogeneity can reflect the presence of distinct 
expression profiles associated to cell subtypes or discrete states which could 
be identified through clustering [@Kiselev2019]. 
Alternatively, cell-to-cell expression heterogeneity can be due to gradual 
changes along biological processes that evolve over time (such as 
development and differentiation) --- these can be characterised using pseudotime
inference methods [@Saelens2019].
More subtle expression variability within a seemingly homogeneous cell 
population can be due to deterministic or stochastic events and is the focus 
of this article. 
The stochastic component of this variability is referred to as transcriptional 
*noise* [@Elowitz2002; @Eling2019]. 

<!--- why is it challenging to study transcriptional noise? ---> 
Transcriptional noise can arise from intrinsic and extrinsic sources of 
variability. Classically, extrinsic noise is defined as stochastic fluctuations 
in cellular components, which is induced by cells residing in different dynamic 
states (e.g. cell size, cell cycle, metabolism, intra- and inter-cellular 
signalling) [@Zopf2013; @Iwamoto2016; @Kiviet2014]. 
Instead, intrinsic noise arises from stochastic effects on biochemical 
processes such as transcription and translation [@Elowitz2002]. 
Intrinsic noise can be modulated by genetic and epigenetic modifications (such 
as mutations, histone modifications, CpG island length and nucleosome 
positioning) [@Eberwine2015; @Faure2017; @Morgan2018] and is usually measured 
at the level of individual genes [@Elowitz2002]. Cell-to-cell gene expression 
variability estimates derived from scRNA-seq data capture a combination of 
these effects, as well as deterministic regulatory mechanisms [@Eling2019]. 
These variability estimates can also be inflated by the technical noise that is 
typically observed in scRNA-seq assays [@Brennecke2013].

Different strategies have been implemented to quantify or attenuate technical
noise in scRNA-seq experiments. For example, external RNA spike-in molecules 
(such as the ones introduced by the External RNA Controls Consortium, ERCCs 
[@Rna2005]) can be added to each cell’s lysate. Spike-ins can be used to inform
quality control steps [@McCarthy2017], data normalisation [@Vallejos2017] as 
well as to infer technical background noise [@Brennecke2013]. 



<!--- BASiCS ---> 
To address these technical issues, the `r Biocpkg("BASiCS")` Bioconductor 
package estimates gene- and cell-specific model parameters that can be used to, 
for example, normalize raw scRNA-Seq counts and to detect highly and lowly 
variable genes [@Vallejos2015BASiCS]. 
`BASiCS` is a hierarchical Bayesian framework that propagates statistical 
uncerstainty into down-stream analysis and allows the decomposition of total 
variance into a biological and technical part by incorporating spike-in reads 
[@Vallejos2015]. Furthermore, `BASiCS` has been extended to perform 
differential mean expression and differential variability testing 
[@Vallejos2016].


<!--- Differential analyses ---> 
<!--- add reference to 11 challenges paper, flexible changes in expression ---> 
Since the era of RNA sequencing, methods for differential expression testing 
of transcript counts across two conditions have been developed 
[@Anders2010; @Robinson2009]. 
Due to high technical variability and sparsity in scRNA-seq data, new 
approaches were developed for differential expression testing specifically 
for scRNA-seq data [@Katayama2013; @Kharchenko2014; @Delmans2016]. 
In contrast to bulk samples, scRNA-seq measures variations in gene expression 
across a population of cells and can therefore be used to test for changes in 
expression variability between two conditions. 
For this, `BASiCS` compares the gene-specific over-dispersion parameters 
between two conditions. These parameters are independent of technical noise 
and can be used as proxy for biolgocial variability [@Vallejos2016]. 
Similar to the mean-variability trend observed for normalized scRNA-Seq data 
[@Brennecke2013], the estimates for over-dispersion parameters decrease with 
mean expression [@Vallejos2016].
To correct for this, BASiCS has been extended to model the mean-variability 
relationship and capture residual over-dispersion estimates that show no 
association to mean expression. 
Therefore, this extension allows to test changes in mean expression in parallel 
to changes in variability [@Eling2018]. 


<!--- Outline ---> 
Here we present a computational workflow for differential expression and 
differential variability testing of scRNA-seq data using the previously 
published BASiCS package [@Vallejos2015; @Vallejos2016; @Eling2017] implemented 
in the statistical computing language R. 
We highlight the use of the `r Biocpkg("scater")` and `r Biocpkg("scran")` 
Bioconductor packages to perform initial quality control and low-level analysis 
[@McCarthy2017; @Lun2016], which is comparable to analyses performed using 
`BASiCS`. Two case studies exemplify the use of `BASiCS` for non-UMI and UMI 
scRNA-Seq data. In the first case, `BASiCS` can be used to detect highly and 
lowly variable genes and to obtain robust, gene-specific estimates to assess 
biological variability in naive CD4^+^ T cells 
[@Martinez-jimenez2017]; for a similar workflow see [@Kim2019].
Furthermore, we compare naive to activated CD4^+^ T cells to highlight the use 
of `BASiCS` to test for changes in mean expression and expression variability.
In the second case, we use droplet-based scRNA-Seq data to detect more subtle 
transcriptional changes during embryonic somitogenesis [@Ibarra-Soria2018]

\newpage

## Outline

1. [Methods](#methods): We describe the main Bioconductor packages used in 
  this worflow and specifically highlight different settings for the MCMC sampler implemented in the `BASiCS` Bioconductor package. 

2. [C1 Fluidigm data](#Tcells): We describe an end-to-end workflow to obtain, 
  process, quality filter raw expression counts of CD4^+^ T cells and how to 
  perform analysis using `r Biocpkg("BASiCS")`. 
  This section is sub-divided into a [single group case](#Tcells-single), 
  where `BASiCS` is used to normalize data and to detect highly and lowly 
  variable genes, and a [two group case](#Tcells-two), for which we perform 
  differential mean expression and differential variability testing.

3. [10X Genomics data](#droplet-data): We highlight the use of `BASiCS` for 
  scRNA-Seq data that do not contain technical spike-in transcript. 
  In this case, technical noise is estimated via experimental replication.
  Similar to the CD4^+^ T cells case, we perform differential mean expression 
  and differential variability testing to detect early cell fate decision events 
  in mammalian somitogenesis.

```{r overview, out.width='50%', fig.cap = 'Computational workflow highlighting the use of BASiCS to analyse single groups or two groups of cells. HVG: highly variable genes; LVG: lowly variable genes.', echo=FALSE, fig.pos='h'}
knitr::include_graphics("figure/Overview.png")
```

# Methods {#methods}

In this workflow, we use a number of Bioconductor and CRAN packages for 
different parts of the analyses. 
Here, we will briefly highlight the main functionalities of these packages 
from a users perspective.

The `r Biocpkg("SingleCellExperiment")` Bioconductor package offers a S4 
class container to store scRNA-Seq count data and their associated gene- and 
cell-specific metadata. 
Throughout this workflow, we perform analyses using a `SingleCellExperiment` 
object that contains (at least) the raw expression counts, gene identifiers, 
batch information and cell identifiers.
The `SingleCellExperiment` function uses a `r Biocpkg("SummarizedExperiment")` 
and takes a the raw expression counts in form of a list, and the cell- and 
gene-specific metadata in form of data frames. 

The `r Biocpkg("scater")` Bioconductor package has been developed to facilitate 
the handling of scRNA-Seq data [@McCarthy2017].
Its main functions include the calculation of quality control (QC) metrics, 
the visualization of such metrics and expression counts, and the normalization 
of expression counts.
We will primarily use the `calculateQCMetrics` function to calculate cell- 
and gene-specific QC metrics, the `plotPCA` function to visualize QC 
metrics, metadata and gene expression, and the `normalize` function to 
pre-normalize expression data.

The `r Biocpkg("scran")` Bioconductor package offers a variety of functions 
for low-level scRNA-Seq data analysis [@Lun2016].
While it contains function for batch correction, doublet detection, estimation 
of cell cycle states, we will use it primarily for pre-normalization in junction
with the `scater` package [@Lun2016pooling] and for modelling the mean-variance 
trend across all genes.
Using the `trendVar` and `decomposeVar` functions will be used to fit a 
mean-dependent trend to the gene-specific variances before decomposing the 
overall variance into technical and biological components. 
Furthermore, we will use the `DM` function to calculate the distance of 
gene-specific squared coefficients of variation (CV2) to a rolling median 
along mean expression [@Kolodziejczyk2015cell].

The `r Biocpkg("BASiCS")` Bioconductor package contains an assembly of 
functions to estimate and analyse gene- and cell-specific model parameters 
[@Vallejos2015BASiCS; @Vallejos2016; @Eling2018].
`BASiCS` is build upon a hierarchical Baysian framework and as such samples 
posterior distribution for each model parameter.
In mathematical terms, the gene expression count $X_{ij}$ for gene $i$ in cell 
$j$ is modelled as:

$$
\begin{aligned}
X_{ij}|\mu_i,\nu_j&\sim{}\text{Poisson}(\nu_j\mu_i)\\
\nu_j|s_j,\theta&\sim{}\text{Gamma}(1/\theta,1/(s_j\theta))\\
\rho_{ij}|\delta_i&\sim{}\text{Gamma}(1/\delta_i,1/\delta_i)
\end{aligned}
$$

where $\mu_i$ explains the gene's mean expression, $\nu_j$ the technical effect 
dominated by the mRNA capture efficiency $s_j$ and the unexplained technical 
noise parameter $\theta$. 
Here, $\phi_j$ is the cell-specifc size factor and $\rho_{ij}$ the biological 
random effect incoroporating the over-dispersion hyper-parameter $\delta_i$.
It is important to note that, in the further analysis, $\mu_i$ represents the
mean expression and $\delta_i$ the biological over-dispersion of each gene.

Due to a strong association between the mean expression and the biological 
over-dispersion, the model has been extended to correct for such confounding 
effect. To this end, the prior distribution for the over-dispersion parameters 
has been changed to:

$$
\delta_i | \mu_i \sim \text{log-t}_{\eta}\left( \text{f}(\mu_i), \sigma^2 \right).
$$

where $\text{f}(\mu_i)$ describes a smooth regression trend between the 
over-dispersion and the mean expression parameters.
This extension introduced the residual over-dispersion parameters 
$\epsilon_i=\delta_i-\text{f}(\mu_i)$ that do not scale with mean expression [@Eling2018].

From a data analysis perspective, the `BASiCS_MCMC` function is the heart of 
the `BASiCS` package and can be run in four different settings (see Table 1). 

: Four settings that can be used to run the `BASiCS_MCMC` function.

                        No regression         Regression           
----------------------- --------------------  -------------------
Using spike-in reads    `WithSpikes = TRUE`   `WithSpikes = TRUE`  
                        `Regression = FALSE`  `Regression = TRUE` 
No spike-ins available  `WithSpikes = FALSE`  `WithSpikes = FALSE` 
                        `Regression = FALSE`  `Regression = TRUE`
----------------------- --------------------  -------------------

If spike-in counts are availabe and should be used to estimate technical noise,
the parameter `WithSpikes` is set to `TRUE` (default).
If the regression between mean expression and over-dispersion should be 
performed, the `Regression` parameters is set to `TRUE` (default).
If the user decides to set `Regression = FALSE`, `BASiCS` will not estimate 
the regression trend and does not supply the residual over-dispersion 
parameters $\epsilon_i$.

The `BASiCS_MCMC` function returns a `BASiCS_Chain` object, which can be used 
for further doenstream analysis as indicated in this workflow.

The `r CRANpkg("coda")` CRAN package contains a variety of functions to assess 
the convergence of a sampled MCMC chain. 
To use `coda` functions, the individual chains returned by `BASiCS` need to be 
transformed into a MCMC object that `coda` recognises using the `coda::mcmc` 
function. `BASiCS` offers a number of functions to visualize the convergence 
of MCMC chains. Nevertheless, we will use the `effectiveSize` function from 
`coda` to compute the effective sample size of individual MCMC chains.

The `r Biocpkg("goseq")` Bioconductor package offers functions to detect the 
enrichment of gene ontologies (GOs) among user-specified gene sets [@Young2010].
Furthermore, `goseq` corrects for gene length biases, which is useful for full 
length scRNA-Seq data as highlighted in the first section. 
In this workflow, we will use `goseq` to detect GO enrichment among 
differentially expressed sets of genes.

For downstream analysis, such as GO enrichment analysis or the biological 
interpretation of individual genes, we need to (i) link each gene's ID to its 
symbol and (ii) calculate each gene's length.
For the first task, the `r Biocpkg("biomaRt")` Bioconductor package annotates a 
wide range of gene and gene product identifiers [@Durinck2005] by accessing the 
BioMart software suite ([http://www.biomart.org](http://www.biomart.org)).
We can use `biomaRt` to link the **Mus musculus** gene IDs and to their gene 
symbols (also referred to as 'gene name'): 


```{r libraries}
library("ggplot2")
library("viridis")
library("biomaRt")
library("EnsDb.Mmusculus.v79")
library("SingleCellExperiment")
library("scran")
library("scater")
library("BASiCS")
library("coda")
library("goseq")
library("org.Mm.eg.db")
library("data.table")
library("pheatmap")
library("ggpointdensity")

## Set theme for ggplot2 plots
theme_set(theme_bw(base_size = 15))
## Directories to store downloaded files and intermediate results
dir.create("rds", showWarnings = FALSE)
dir.create("downloads", showWarnings = FALSE)
```

```{r obtain-gene-symbols}
if (!file.exists("rds/genenames.rds")) {
  # Initialize mart
  ensembl <- useMart("ensembl")

  # Select dataset
  ensembl <- useDataset(
    dataset = "mmusculus_gene_ensembl",
    mart = ensembl
  )

  # Select gene ID and gene name
  genenames <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    mart = ensembl
  )
  rownames(genenames) <- genenames$ensembl_gene_id
  saveRDS(genenames, "rds/genenames.rds")
} else {
  genenames <- readRDS("rds/genenames.rds")
}
```

For the second task, and to perform GO enrichment analysis, we further collected 
the gene length information of each gene.
This can be extracted from the `r Biocpkg("EnsDb.Mmusculus.v79")` annotation 
package.
This resource offers gene annotations, such as exon positions and promoters, for 
the Ensembl data base.

```{r gene-length}
if (!file.exists("rds/genelength.rds")) {
  # Build exon list
  exons_list <- exonsBy(EnsDb.Mmusculus.v79, by = "gene")

  # Calculate summed length of all exons
  genelength <- unlist(lapply(
    exons_list,
    function(x) {
      sum(width(reduce(x)))
    }
  ))
  saveRDS(genelength, "rds/genelength.rds")  
}
genelength <- readRDS("rds/genelength.rds")

# Add gene length to gene names
genenames$gene_length <- genelength[genenames$ensembl_gene_id]
```

## Operation

The following R, Bioconductor and package version were used for this workflow:

**R version**: `r R.version.string`

**Bioconductor version**: `r BiocManager::version()`

**Packages**: BASiCS `r packageVersion("BASiCS")`, scran 
`r packageVersion("scran")`, scater `r packageVersion("scater")`, coda 
`r packageVersion("coda")`, goseq `r packageVersion("goseq")`    

For the full list of packages used, please see the [Session Info](#session-info).

# C1 Fluidigm data: Analysis of naive CD4^+^ T cells {#Tcells}

For the first case study, we will use scRNA-Seq data of CD4^+^ T cells, which 
were processed using the C1 Single-Cell Auto Prep System (Fluidigm^®^) using 
10–17 $\mu{}m$ integrated fluidic circuits (IFCs). 
Martinez-Jimenez _et al._ profiled naive and activated CD4^+^ T cells from 
young and old animals across two mouse strains to test for changes in 
expression variability that occur during organismal ageing 
[@Martinez-jimenez2017]. Naive or effector memory CD4^+^ T cells were extracted 
from spleens of young or old animals and filtered using either 
magnetic-activated cell sorting (MACS) or fluorescence activated cell sorting 
(FACS) (labelled as MACS-purified Naive, FACS-purified Naive or FACS-purified 
Effector Memory).
For clarification, naive CD4^+^ T cells are also referred to as 'unstimulated' 
CD4^+^ T cells.

In addition to profiling naive CD4^+^ T cells, the authors stimulated half 
of the naive cells for 3 hours using _in vitro_ antibody stimulation (labelled 
as Active).
Naive as well as activated CD4^+^ T cells were processed using the 
C1 Fluidigm^®^ system to capture and lyse cells, and to reverse transcribe 
and amplify mRNA prior to sequencing.
Cells were isolated from B6 (C57BL/6J, _Mus musculus domesticus_) and CAST 
(_Mus musculus castaneus_) animals to profile the evolutionary conservation 
of transcriptional dynamics during ageing.
External spike-in RNA has been added to quantify technical variability across 
all cells. All experiments were performed in replicates (also referred to as 
batches) to control for batch effects.

We will begin the workflow with obtaining the data before quality control, 
running the BASiCS model, and performing further downstream analysis.

## Obtaining the data

The raw counts of the full dataset can be obtain from ArrayExpress under the 
accession number 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
In this dataset, the column names contain the library identifier of the original 
experiment while the row names of the matrix store the individual gene names. 
The dataset contains reads mapping to ERCC spike-in genes [@Rna2005], which 
`BASiCS` uses to estimate and remove technical noise.

```{r naive-data}

if (!file.exists("downloads/raw_data.txt")) {
  # Download raw counts file
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-4888/"
  file <- "E-MTAB-4888.processed.1.zip"
  destfile <- "downloads/raw_data.txt.zip"
  download.file(
    paste0(website, folder, file),
    destfile = destfile
  )
  unzip("downloads/raw_data.txt.zip", exdir = "downloads")
  file.remove("downloads/raw_data.txt.zip")
}

# Read in raw data
CD4_raw <- read.table("downloads/raw_data.txt", header = TRUE, sep = "\t")
CD4_raw <- as.matrix(CD4_raw)

# Show row and column names
head(colnames(CD4_raw))
head(rownames(CD4_raw))

# ERCC spike-in genes
head(rownames(CD4_raw)[grepl("ERCC", rownames(CD4_raw))])
```

To link the library identifiers to the experimental conditions, the authors 
provide a metadata file that can be accessed online under the same accession 
number.

```{r selecting-serum-cells}
download_file <- function(file, website, folder, destfile = file) {
  if (!file.exists(destfile)) {
    download.file(paste0(website, folder, file), destfile)
  }
}

if (!file.exists("downloads/metadata_file.txt")) {
  # Download raw counts file
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-4888/"
  file <- "E-MTAB-4888.additional.1.zip"
  destfile <- "downloads/metadata.txt.zip"
  download.file(
    paste0(website, folder, file),
    destfile = destfile
  )
  unzip("downloads/metadata.txt.zip", exdir = "downloads")
  file.remove("downloads/metadata.txt.zip")
}
# Read in metadata file
CD4_metadata <- read.table("downloads/metadata_file.txt", header = TRUE, sep = "\t")

# Save library identifier as rownames
rownames(CD4_metadata) <- CD4_metadata$X

# Show metadata entries
head(CD4_metadata)
```

This metadata file contains the library identifiers (*X*), the strain 
information (*Strain*), the relative age of the animals (*Age*), the 
stimulation state of the cells (*Stimulus*), the batch information indicating 
the different mice used (*Individuals*), and the purification method used 
(*Celltype*). 

## Filtering the data


**TODONE: update with altExp**

In the next step, we will first generate a `r Biocpkg("SingleCellExperiment")` 
(SCE) object that contains all cells and that stores cell- and gene-specific 
metadata.
This data class offers convenient ways to subset, and to set and retrieve cell- 
and gene-specific information.  
We will also store information on the spike-in molecules using the `altExp` 
accessor. This allows us to store alternative experimental assays other
than endogenous genes --- in this case, technical (spike-in) genes.

```{r CD4-SCE-object}
# Load library
bio_counts <- CD4_raw[!grepl("ERCC", rownames(CD4_raw)), ]
spike_counts <- CD4_raw[grepl("ERCC", rownames(CD4_raw)), ]
# Generate the SingleCellExperiment object
sce_CD4_all <- SingleCellExperiment(
  assays = list(counts = as.matrix(bio_counts)),
  colData = CD4_metadata[colnames(CD4_raw), ]
)

altExp(sce_CD4_all, "spike-ins") <- SummarizedExperiment(
  assays = list(counts = spike_counts)
)
```

For further downstream analysis, we select naive and activated CD4^+^ T cells 
from young B6 animals that were obtained using the MACS-based cell selection.
It is crucial that proper quality control (QC) and gene filtering is performed 
before running BASiCS, and, in general, before performing meaningful 
computational analysis on biological data.

```{r naive-activated-CD4-SCE-object}
ind_select <- sce_CD4_all$Strain == "Mus musculus domesticus" &
  sce_CD4_all$Age == "Young" &
  sce_CD4_all$Celltype == "MACS-purified Naive"
sce_naive_active <- sce_CD4_all[, ind_select]
```

Prior to cell-specific quality control, we will remove all genes that are not
detected in at least 2 cells across both conditions.
Furthermore, we remove genes that are not expressed with an average count of 1 
across all cells.
These thresholds need to be set dataset-specifically and careful gene-specific 
quality metrics need to be closely examined as suggested by the 
`r Biocpkg("SimpleSingleCell")` Bioconductor workflow [@Lun2016].

```{r gene-selection}
# Remove genese)
ind_expressed <- rowSums(counts(sce_naive_active) > 0) > 1 &
  rowMeans(counts(sce_naive_active)) >= 1
sce_naive_active <- sce_naive_active[ind_expressed, ]
```

In the next step, we will use the `r Biocpkg("scran")` and 
`r Biocpkg("scater")` Bioconductor packages for initial normalization and 
visualization of quality metrics [@Lun2016,@McCarthy2017].
The normalization at this point is needed to avoid biases in the visualization 
due to differences in the mRNA content between cells.
In line with the normalization strategy of BASiCS, we use the spike-in reads 
for normalization.

```{r pre-normalization}
# Pre-normalization of data for visualization purposes
sce_naive_active <- computeSpikeFactors(sce_naive_active, spikes = "spike-ins")
sce_naive_active <- logNormCounts(sce_naive_active)
```

The `Biocpkg("SimpleSingleCell")` Bioconductor workflow provides an extensive 
overview on important aspects of how to perform low-level analysis of scRNA-Seq 
data, including quality control [@Lun2016].
The `calculateQCMetrics` function of the `scater` package can be used to 
calculate a number of cell- and gene-specific quality metrics.
Furthermore, `scater` offers the `runPCA` function to compute a principal 
component analysis (PCA) across all cells.

```{r scater-QC-metrics}
# Calculate quality metrics
sce_naive_active <- addPerCellQC(sce_naive_active, use_altexps = TRUE)
sce_naive_active <- addPerFeatureQC(sce_naive_active)

clean_colnames <- make.names(colnames(colData(sce_naive_active)))
colnames(colData(sce_naive_active)) <- clean_colnames

# Calculate PCA
sce_naive_active <- scater::runPCA(sce_naive_active)
```

For the CD4^+^ T cell dataset, the authors removed empty capture sites and 
sites which contained multiple cells or debris as observed by visual inspection. 
Furthermore, they removed cells which had fewer than 1,000,000 total reads, 
cells where less than 20% of reads mapped to endogenous genes, cells in which 
less than 1,250 or more than 3,000 genes were detected and cells with more than 
10% or less than 0.5% reads mapping to mitochondrial genes 
[@Martinez-jimenez2017].

Since these data have been quality filtered in the original publication, we will 
only visualize the distribution of quality metrics across the cells.
The highlighted quality metrics can otherwise be used to identify low quality 
cells.
These metrics include (among others): number of endogeneous genes detected per 
cell, total number of reads per cell, the fraction of reads mapping to spike-in 
and endogeneous genes.
The main aim is to identify broken or dying cells, and possibly empty wells.
For an extenive discussion on quality metrics for scRNA-Seq data, see Ilicic 
*et al.* [@Ilicic2016].

The activation status and batch information for each individual cell of the 
selected dataset can be seen in Figure \@ref(fig:visualiztion-stimulus-batch).

```{r visualiztion-stimulus-batch,fig.height=2, fig.cap="Visualization of the cell stimulus (left) and the batch information per cell (right). Cells from two animals were captured either in the naive or activated state.", fig.pos='h'}
# Visualize the conditions and batch structure
p_stimulus <- scater::plotPCA(sce_naive_active, colour_by = "Stimulus")
p_batch <- scater::plotPCA(sce_naive_active, colour_by = "Individuals")
multiplot(p_stimulus, p_batch, cols = 2)
```

The data splits into two conditions: naive and activated CD4^+^ T cells.
Furthermore, we do not detect batch effects or outlier cells based on PCA 
visualization.

In the next step, we will visualize selected cell-specific quality metrics 
overlayed on the PCA.
Figure \@ref(fig:no-genes_total-counts) highlights the number of endogeneous 
genes detected per cell and the total number of counts.
Both metrics can be used to detect empty wells or broken cells (low values) 
and potentially doublets (high values).

```{r no-genes-total-counts, fig.height=2, fig.cap="Visualization of the number of biological genes detected per cell (left) and the total number of reads per cell (right).", fig.pos='h'}
# Visualize number of endogeneous genes detected
p_total_features <- scater::plotPCA(
    sce_naive_active, 
    colour_by = "detected"
  ) +
  scale_fill_viridis_c(name = "Number of genes", trans = "log10")

# Visualize log10-transformed total number of counts
p_total_counts <- scater::plotPCA(
    sce_naive_active, 
    colour_by = "sum"
  ) +
  scale_fill_viridis_c(name = "Number of counts", trans = "log10")
multiplot(p_total_features, p_total_counts, cols = 2)
```

We detect a higher number of expressed genes and a higher total read count in
activated cells. 
Furthermore, cells within each group show a wide distribution of these quality 
measures without clear outlying cells.

A widely used quality visualisation is to plot the total number (or fraction) of 
spike-in counts versus the total number (or fraction) of endogeneous counts 
(Figure \@ref(fig:ERCC-endogeneous)).
In such a plot, low quality wells are characterised by a high fraction of 
spike-in counts and a low fraction of endogeneous counts.

```{r ERCC-endogeneous, fig.height=3, fig.width=3, fig.cap="The number of spike-in counts per cells is plotted against the number of endogeneous counts per cell. A dashed line indicates the minimum level of spike-in counts, below which cells are removed.", fig.pos='h'}
# Plot the fraction of reads mapping to spike-ins
# versus the number of reads mapping to endogeneous genes
ggplot(as.data.frame(colData(sce_naive_active))) +
  geom_point(aes(sum, altexps_spike.ins_sum)) +
  geom_vline(xintercept = 10^5.8, linetype = "dashed", colour = "grey60") +
  scale_x_log10() +
  scale_y_log10()
```

Since we are lacking the information of the total reads per cell (including the 
non-mapped and intronic reads), we can solely filter cells based on the total 
number of endogeneous counts (assuming equal numbers of spike-in molecules per 
well). Nevertheless, we remove two cells that showed unusually low number of 
reads mapping to endogeneous genes. We indicate the threshold used for filtering
on the plot using a dashed
line.

```{r}
# Remove two cells that appear to be outliers
ind_retain <- log10(sce_naive_active$sum) > 5.8
sce_naive_active <- sce_naive_active[, ind_retain]
```

It is crucial that an in-depth quality control is performed to remove 
low-quality or outlying cells.
Furthermore, such a quality control step can help understand where possible 
confounding effects arise that can influence the interpretation the results 
of downstream analyses.

## Calculating the molecule count for spike-in genes

BASiCS requires the absolute molecule count of the spike-in transcripts that
were added to each well. To calculate the molecule count, we require the 
dilution and the concentration of the spike-in mix.
For this, a table of the spike-in concentrations can be downloaded from 
[https://www.thermofisher.com](https://www.thermofisher.com/order/catalog/product/4456740).
The file contains the concentrations of 2 ERCC spike-in mixes.

For the CD4^+^ T cell data, the authors added a 1:50,000 dilution of the ERCC 
spike-in mix 1 [@Martinez-jimenez2017].
We will first download the concentration information.

```{r spike-in_download}
# Read in the spike-in concentrations
website <- "https://assets.thermofisher.com/"
folder <- "TFS-Assets/LSG/manuals/"
file <- "cms_095046.txt"
download_file(file, website, folder, "downloads/spike_info.txt")

ERCC_conc <- read.table(
  "downloads/spike_info.txt",
  sep = "\t", header = TRUE
)
```

The concentration is given in units of attomoles per $\mu{}l$. 
We will first calculate the concentration in moles per $\mu{}l$.

```{r}
# Moles per micro litre
ERCC_mmul <- ERCC_conc$concentration.in.Mix.1..attomoles.ul. * (10^(-18))
```

From this, we can calculate the molecule count per $\mu{}l$ using the fact that 1 mole is equal to $6.02214076\cdot10^{23}$ molecules.

```{r}
# Molecule count per micro litre
ERCC_countmul <- ERCC_mmul * (6.02214076 * (10^23))
```

During the preparation of the reaction mix, the authors diluted this mix by a
factor of 1:50,000 [@Martinez-jimenez2017].
The actual molecule number of spike-ins can therefore be calculated per $\mu{}l$:

```{r}
ERCC_count <- ERCC_countmul / 50000
```

The volume per well in the IFC chip is 9 nano litre 
[https://www.fluidigm.com/faq/ifc-9](https://www.fluidigm.com/faq/ifc-9).
We therfore need to calculate the number of molecules in 9 nano litre reaction mix.

```{r}
ERCC_count_final <- ERCC_count * 0.009
```

Depending on the technology used to capture and process single cells, and the 
dilution of the spike-in mix, the absolute number of spike-ins per reaction can 
change.
The absolute amount of spike-ins per reaction is purely a scale ... 
BASiCS assumes that the quantity of spike-ins is consistent in each well in
each experiment. While the quantity used must remain constant between wells and
experiments, the scale does not affect the results, provided the spike-ins
are at a reasonable level. In particular, they should not be in such a low 
concentration that they are rarely detected, and they should not be at such
a high concentration that the majority of the sequencing reads map to the 
spike-in molecules.

**TODONE: Add explanation that the number of spike-ins need to be consistent 
across all wells and experiments but that the scale does not effect the results.**

We can now use the molecule count to prepare the BASiCS data object.
To incorporate the spike-in molecule counts within the 
`r Biocpkg("SingleCellExperiment")` object that BASiCS requires, the first 
column must contain the names associated to the spike-in genes. 
The second column must contain the input number of molecules for the spike-in 
genes (amount per reaction).


```{r spike-info}
# Prepare the data.frame
ERCC_count <- data.frame(
  row.names = ERCC_conc$ERCC.ID,
  Names = ERCC_conc$ERCC.ID,
  count = ERCC_count_final
)
```

## Single condition example: Naive CD4^+^ T cells {#Tcells-single}

To highlight the use of BASiCS to analyse cells in the single-condition case,
we select naive CD4^+^ T cells of young B6 animals.
Here, BASiCS can be used to identify highly- and lowly-variable genes and 
calculate interpretable gene- and cell-specific parameters.
Among others, these include gene-specific parameters for mean expression, 
over-dispersion (biological variability) and residual over-dispersion 
(biological variability after correcting for the mean expression effect).

### Preparing the BASiCS data object {#Tcells-filtering}

The BASiCS Data object is an object of the class 
`r Biocpkg("SingleCellExperiment")`.
The `newBASiCS_Data` function can be used to create the required 
`SingleCellExperiment` object based on the following information:

* Counts: a matrix of raw expression counts with dimensions $q$ times $n$, 
  where $q$ is the number of genes (technical + biological) and $n$ is the number 
  of cells. Gene names must be stored as row names of the counts matrix.

* Tech: a vector of `TRUE/FALSE` elements with length $q$. If `Tech[i] = FALSE` 
  the gene i is biological; otherwise the gene is spike-in. This vector must 
  be specified in the same order of genes as in the counts matrix.

* SpikeInfo: a `data.frame` with $q-q_0$ rows where $q_0$ is the number 
  of biological genes. The first column must contain the names associated to 
  the spike-in genes. The second column must contain the input number of 
  molecules for the spike-in genes (amount per cell).

* BatchInfo (optional argument): vector of length $n$ to indicate batch 
  structure in situations where cells have been processed using multiple 
  batches.

We will first select the naive cells from the `SingleCellExperiment` object 
that was generated above.

```{r SCE-naive}
ind_stimulated <- sce_naive_active$Stimulus == "Unstimulated"
sce_naive <- sce_naive_active[, ind_stimulated]
ind_expressed <- rowSums(counts(sce_naive) > 0) > 1 & 
  rowMeans(counts(sce_naive)) >= 1
sce_naive <- sce_naive[ind_expressed, ]
```

Next, we will use the `newBASiCS_Data` function to re-generate the 
`SingleCellExperiment` object for the use with BASiCS.

```{r Data-naive}
# Here is the first time that we use BASiCS

# Select the ERCC spike-ins of the dataset
counts <- counts(sce_naive)
spikes <- assay(altExp(sce_naive, "spike-ins"))
spikes_present <- rowSums(spikes) != 0
## Remove spike-ins that are not present from matrix and SCE object
spikes <- spikes[spikes_present, ]
altexp_present <- altExp(sce_naive, "spike-ins")[spikes_present, ]
altExp(sce_naive, "spike-ins") <- altexp_present
ind_spike <- c(rep(FALSE, nrow(counts)), rep(TRUE, nrow(spikes)))
spike_input <- ERCC_count[rownames(spikes), ]

# Generate the SingleCellExperiment object
data_naive <- newBASiCS_Data(
  Counts = rbind(counts, spikes),
  Tech = ind_spike,
  SpikeInfo = spike_input,
  BatchInfo = sce_naive$Individuals
)
data_naive
```

Alternatively, when using datasets that contain spike-in genes, the 
original `SingleCellExperiment` object can be extended by simply specifying a 
`BatchInfo` slot in the `colData` object and by adding the `SpikeInfo` object 
to the `metadata` slot.

```{r Data-naive-alternative}
data_naive <- sce_naive
colData(data_naive)$BatchInfo <- colData(sce_naive)$Individuals
metadata(data_naive)$SpikeInput <- spike_input
```

After creating the `SingleCellExperiment` object that contains all information 
that `BASiCS` requires, the MCMC sampler can be run to generate posterior 
estimates of model parameters.

### Running the MCMC

It is recommended to run the `BASiCS_MCMC` sampler for at least 40,000 
iterations to assure convergence.
However, if datasets are large and each condition contains hundreds of cells 
from a homogeneous population, BASiCS can be run with fewer (e.g. 20,000) 
iterations (see [10X Genomics data](#droplet-data)).
However, for convenience, `BASiCS_MCMC` can be run with very few (e.g 1,000) 
iterations to test whether the sampler breaks.

Here, we run the MCMC sampler for 40,000 iterations, using an initial 20,000
iterations as burn in an a thinning step of 20 iterations.
Since the dataset contains spike-in genes, we run the sampler with 
`WithSpikes = TRUE` and we also want to correct for the mean-variance trend 
using `Regression = TRUE`. For further information see [Methods](#methods).

```{r MCMC-naive, eval = FALSE}
MCMC_naive <- BASiCS_MCMC(
  Data = data_naive,
  PrintProgress = FALSE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE
)
```

This sampler runs for *167 minutes* on a 1.4 GHz Intel Core i5 procesor with 4GB
RAM and produces a `BASiCS_Chain` data object.
For comparison, this sampler runs for *97 minutes* on a 3.4 GHz Intel Core 
i7 procesor with 16GB RAM.
For convenience, the MCMC chain can be obtained online at 
[https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020](https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020).

```{r download-chain-naive}
download_file(
  file = "MCMC_naive.rds",
  website = "https://git.ecdf.ed.ac.uk/vallejosgroup/",
  folder = "basicsworkflow2020/raw/master/MCMCs/",
  destfile = "rds/MCMC_naive.rds"
)

MCMC_naive <- readRDS("rds/MCMC_naive.rds")
```

The `BASiCS_Chain` object contains a list of matrices that store the 
individual MCMC draws per parameter. Each matrix contains the cell- or 
gene-specific parameters in the columns and the MCMC draws in the rows.
`BASiCS` provides the `displayChainBASiCS` function to access the cell- or 
gene-specific parameters.
As an example, we access the first 10 draws for $\mu_i$ of the first 10 genes.

```{r displayChainBASiCS}
displayChainBASiCS(MCMC_naive, Param = "mu")[1:2, 1:10]
```

We ran the MCMC samples for 40,000 iterations, with 20,000 iterations and a
thining value of 20. This results in the storage of 1000 draws for each 
parameter in the `BASiCS_Chain` object:

```{r dim-displayChainBASiCS}
dim(displayChainBASiCS(MCMC_naive, Param = "mu"))
```

### Validating the MCMC convergence {#naive-convergence}

In the next step, we need to validate the convergence of the chain to ensure 
robust downstream analysis. There are multiple ways to visualize and 
test the convergence of MCMC chains (see [@CowlesCarlin1996], 
[@BrooksGelman1998]).
The `r CRANpkg("coda")`
contains diagnostic and plot functions for this task ([@CODA2006]).
Here, we highlight two ways of assessing the convergence of the MCMC sampler by 
(i) plotting trace plots, sample densities and the chain autocorrelation, and 
(ii) plotting the the effective sample size across multiple parameters.
Trace plots show the sampled parameter values over time. A chain converged when 
the sample density (in form of a histogram) shows a unimodal distribution.
The autocorrelation of an MCMC chain is defined as the Pearson correlation 
between the chain and a time-delayed version of the chain. 
The difference in time-points is referred to as 'lag'.
The chain converged if the autocorrelation (except for lag = 1) is small 
(e.g. < 0.25).

Effective sample size is a measure of the number of independent samples 
generated for a model parameter [@Gelman2014]. Simply, it is defined as the 
number of samples taken relative to the total autocorrelation.
More formally, it is defined as follows:

$$
  \mbox{ESS} = \frac{n}{1 + 2\sum_{k=1}^\infty \rho(k)}
$$
where $n$ is the number of samples and $\rho(k)$ is the autocorrelation at lag 
$k$. We can visualise this parameter using two 

```{r convergence-naive}
# Convergence of mean expression parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "mu", Gene = 1)
plot(MCMC_naive, Param = "mu", Gene = 7216)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "mu")

# Histogram of sample size for mu, as some genes seem to have low values for mu.
BASiCS_DiagHist(MCMC_naive, Param = "mu")

# Convergence of over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "delta", Gene = 100)
plot(MCMC_naive, Param = "delta", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "delta")

# Convergence of residual over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "epsilon", Gene = 200)
plot(MCMC_naive, Param = "epsilon", Gene = 9000)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "epsilon")

# Convergence of mRNA capture efficiency parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_naive, Param = "s", Cell = 10)
plot(MCMC_naive, Param = "s", Cell = 50)

# Effective sample size
BASiCS_DiagPlot(MCMC_naive, Param = "s")
```

We can see several genes show very low sample size for mu. We can identify 
these using functions from the `CRANpkg(coda)`.

```{r low-ess-genes}

ess <- effectiveSize(mcmc(displayChainBASiCS(MCMC_naive, "mu")))
low_ess_genes <- names(ess[ess < 100])
hist(
  ess,
  breaks = "FD",
  main = "Effective sample size",
  xlab = "Effective sample size"
)
abline(v = 100, lty = "dashed", col = "grey60")
head(low_ess_genes)
```

Given that the sample has generated less than 100 effectively independent 
samples for these genes, there may not be sufficient posterior information to 
reliably calculate differences in mean expression, and it would be appropriate 
to exclude these genes from downstream analysis.

## Downstream analysis

In this section, we will highlight the use of BASiCS when cells of a single 
condition are analysed.
The downstream analysis includes: normalization, variance decomposition, 
detection of highly and lowly variable genes and the use of gene-specific 
parameters as interpretable variability measures.
Furthermore, we will compare the results in the individual steps with results 
obtained using the `Biocpkg("scran")`.

### Normalization

Posterior estimates of cell-specific parameters can be used to normalize the 
data and correct for biases in mRNA content [@Vallejos2017].
To perform normalization, BASiCS provides the `BASiCS_DenoisedCounts` and the 
`BASiCS_DenoisedRates` functions. 
*TODO: Add more details on the DenoisedCounts function*
These functions take the `SingleCellExperiment` and `BASiCS_Chain` objects as 
inputs.

```{r normalization-naive}
counts_denoised <- BASiCS_DenoisedCounts(Data = data_naive, Chain = MCMC_naive)
```

Alternatively, *TODO: add the DenoisedRates*

These normalized counts can be further used for dimensionality reduction and
clustering as explained elsewhere *TODO: ref,ref*.

### Lowly and highly variable gene detection

BASiCS offers a function to select genes with large and small biological 
variance. When the MCMC sampler was run with `Regression = TRUE` (default), 
the `BASiCS_DetectHVG` and `BASiCS_DetectLVG` functions take the 
`BASiCS_Chain` object and a quantile threshold.
Using the residual over-disperison parameters, genes are ranked by their 
variability and the `BASiCS_DetectHVG` function selects the (for example) top 
10% of highly variable genes (`PercentileThreshold = 0.9`).
Similarly, when detecting lowly variable genes, the `BASiCS_DetectLVG` selects 
the top 10% of lowly variable genes (`PercentileThreshold = 0.1`).
The propability threshold for a gene showing higher variability than the 
percentile threshold is found by controling the EFDR to 10% (default).

```{r naive-HVG-LVG}
# Highly variable genes
HVG <- BASiCS_DetectHVG(MCMC_naive, PercentileThreshold = 0.9)

# Lowly variable genes
LVG <- BASiCS_DetectLVG(MCMC_naive, PercentileThreshold = 0.1)
```

This analysis results in the detection of *`r sum(HVG$Table$HVG)`*
highly variable genes and *`r sum(LVG$Table$LVG)`*
lowly variable genes.

The `Biocpkg("scran")` provides similar functions to detect HVGs and we can 
compare the results of both methods.
`scran` first fits a smooth regression between the variance of the 
log-transformed expression of the spike-in transcripts and their mean 
abundance using the `trendVar` function.
Afterwards, the `decomposeVar` function decomposes the gene-specific variance 
into a biological and technical component.

```{r HVG-LVG-scran}
# Fit the mean-variance trend
means <- rowMeans(logcounts(sce_naive))
vars <- rowVars(logcounts(sce_naive))
var_fit <- scran::fitTrendVar(means, vars)

# Variance decomposition
var_out <- scran::modelGeneVar(sce_naive)
```

As proposed by the `SimpleSingleCell` workflow, the HVGs are described as 
displaying a biolgical variance component of larger than 0.5 while controlling 
the FDR to 5% [@Lun2016].
*TODO: Make sure this is still in the current version of SimpleSingleCell*.
We can then compare the the overlap of the HVG identified by scran and by BASiCS.

```{r scran-HVG}
ind_hvg <- which(var_out$FDR <= 0.05 & var_out$bio >= 0.5)
hvg_out <- var_out[ind_hvg, ]
hvg_out <- hvg_out[order(hvg_out$bio, decreasing = TRUE), ]
nrow(hvg_out)

# Intersection between BASiCS and scran HVG
length(intersect(rownames(hvg_out), HVG$Table$GeneName[HVG$Table$HVG]))

# Compare BASiCS and scran results
HVG_res <- paste(
  HVG$Table$HVG, 
  var_out[HVG$Table$GeneName, "FDR"] <= 0.05 &
    var_out[HVG$Table$GeneName, "bio"] >= 0.5
)

ggplot() +
  geom_point(
    data = data.frame(
      Mu = HVG$Table$Mu,
      Epsilon = HVG$Table$Epsilon,
      HVG = HVG_res
    ),
    aes(log(Mu), Epsilon, colour = HVG)
  )
```

*`r length(intersect(rownames(hvg_out), HVG$Table$GeneName[HVG$Table$HVG]))`*
of the *`r nrow(hvg_out)`* HVG genes of scran are among the
*`r sum(HVG$Table$HVG)`*
HVGs identified by BASiCS.

### Mean-variance trend

*TODO: Move this up*

Numerous studies have highlighted the relationship between gene-specific 
variability measures such as the squared coefficient of variation and mean 
abundance *TODO: ref,ref,ref*.
BASiCS provides the `BASiCS_ShowFit` function that plots the gene-specific 
over-dispersion parameters (delta) versus mean expression parameters (mu). 

```{r naive-fit}
BASiCS_ShowFit(MCMC_naive)
```

Here, we observe that the over-dispersion estimates are negatively associated 
with mean expression.
However, by performing the regression between over-dispersion and mean 
expression, we can correct for this trend and obtain variability measures that 
show no correlation with mean expression [@Eling2018].
The purple points in the plot indicate genes that are not expressed in at least 
2 cells.
BASiCS automatically excludes these genes due to challenges in interpreting 
variability estimates and changes in variability for genes that are only 
expressed in one cell.

We can now compare the gene-specific variability measures (over-dispersion and 
residual over-dispersion) to previously used measures to quantify cell-to-cell 
expression variability [@Brennecke2013,Ola 2015].

### Comparison to variance, Fano factor, CV2, and DM

Widely used measures of expression variability include the variance 
[@Shalek2014], the Fano factor (variance divided by mean expression) 
https://www.nature.com/articles/nbt.2642
https://www.nature.com/articles/nmeth.2930
https://link.springer.com/article/10.1007/s00216-008-2431-z
*TODO: refs* and 
the coefficient of variation (CV, variance divided by squared mean expression) 
https://www.nature.com/articles/nbt.3102
https://www.nature.com/articles/nmeth.2645
*TODO: refs*. 
Here, we will highlight the mean-variance realtionship for each variability 
measures. For this analysis, we exclude genes that are not expressed in at 
least 2 cells.
These genes can be identified in the 
`displayChainBASiCS(MCMC_naive, Param = "epsilon")` to contain `NA`.

```{r variability-measures}
# Exclude ERCCs
counts_denoised <- counts_denoised[!grepl("ERCC", rownames(counts_denoised)), ]

# Exclude genes
eps_not_na <- !is.na(displayChainBASiCS(MCMC_naive, Param = "epsilon")[1, rownames(counts_denoised)])
counts_denoised <- counts_denoised[eps_not_na, ]

# Variance
var_genes <- apply(counts_denoised, 1, var)
mean_genes <- apply(counts_denoised, 1, mean)

ggplot(
    data.frame(
      variance = var_genes,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(variance))) +
  scale_color_viridis()

# Fano factor
ggplot(
    data.frame(
      fano = var_genes / mean_genes,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(fano))) +
  scale_color_viridis()

# Squared coefficient of variation
ggplot(
    data.frame(
      CV2 = var_genes / mean_genes^2,
      mean = mean_genes
    )
  ) +
  geom_pointdensity(aes(log(mean), log(CV2))) +
  scale_color_viridis()
```

We see that all measures correlate with mean expression.
The same is true for the over-dispersion parameters as estimated by BASiCS as
shown below. Again, for this comparison, we exclude genes that do not show 
expression in at least 2 cells

```{r CV-comparison-BASiCS}
summary_naive <- Summary(MCMC_naive)
# Remove genes
eps_not_na <- !is.na(displaySummaryBASiCS(summary_naive, Param = "epsilon")[, "median"])
mu_naive <- displaySummaryBASiCS(summary_naive, Param = "mu")[eps_not_na, ]
delta_naive <- displaySummaryBASiCS(summary_naive, Param = "delta")[eps_not_na, ]

# Over-dispersion versus mean expression
ggplot(
    data.frame(
      mu = mu_naive[, "median"],
      delta = delta_naive[, "median"]
    )
  ) +
  geom_pointdensity(aes(log(mu), log(delta))) +
  scale_color_viridis()

# Compare delta to CV2
ggplot(
    data.frame(
      CV2 = var_genes / mean_genes^2,
      delta = delta_naive[rownames(counts_denoised), "median"]
    )
  ) +
  geom_pointdensity(aes(log(CV2), log(delta))) +
  scale_color_viridis()
```

The over-dispersion parameters estimated using BASiCS show strong correlation 
with the CV2. Recently, we extended BASiCS to avoid the mean-variability 
relationship by performing an internal regression between the over-dispersion 
and mean expression parameters (as visualized in figure *Figure showFit*).
Similarly, Kolodziejczyk _et al._ used the distance to a rolling median (DM) 
along the mean-variability trend to correct for this confounding factor 
[@Kolodziejczyk2015cell].
Here, we highlight how to obtain the residual variability estimates using 
`BASiCS` and `scran`.

```{r mean-dispersion-plots}
# Residual over-dispersion estimates
epsilon_naive <- displaySummaryBASiCS(summary_naive, Param = "epsilon")[eps_not_na, ]

# Residual over-dispersion versus mean expression
ggplot(
    data.frame(
      mu = mu_naive[, "median"],
      epsilon = epsilon_naive[, "median"]
    )
  ) +
  geom_pointdensity(aes(log(mu), epsilon)) +
  scale_color_viridis()

# DM values
DM.naive <- scran::DM(mean = mean_genes, cv2 = var_genes / mean_genes^2)

# DM versus mean expression
ggplot(
    data.frame(
      mean = mean_genes,
      DM = DM.naive
    )
  ) +
  geom_pointdensity(aes(log(mean), DM)) +
  scale_color_viridis()

# Compare residual over-dispersion and DM
ggplot(
    data.frame(
      epsilon = epsilon_naive[rownames(counts_denoised), "median"],
      DM = DM.naive
    )
  ) +
  geom_pointdensity(aes(epsilon, DM)) +
  scale_color_viridis()
```

Neither the DM nor the residual over-dispersion estimates show association 
with mean expression.
Furthermore, the mean-independent variability measures display high correlation.
These measures can be used to associate genomic features 
[@Morgan2018,@Faure2017] or transcriptional dynamics [@Antolovic2017] to 
gene expression variability.
While the DM is calculated as a point estimate, BASiCS stores each posterior 
sample within the `BASiCS_Chain` object.
They can be accessed using the `displayChain` function, which displays cell- 
or gene-specific samples in form of a matrix where each column contains cell- 
or gene-specific paramters and rows contain the MCMC samples.

```{r individual-samples}
displayChainBASiCS(MCMC_naive, Param = "epsilon")[1:10, 1:10]
```

**TODO: Not sure if we need this**
By testing a certain association (for example between CpG island length and 
variability [@Morgan2018]) for each MCMC sample, one can generate a _post-hoc_ 
posterior distribution of the test statistic. 

The workflow so far highlights the use of BASiCS for analysing cells of a 
single condtion.

## Differential testing between naive and activated CD4^+^ T cells (two group example) {#Tcells-two}

This section highlights the use of BASiCS to perform differential testing 
(mean and variability) between cells of two condtions. 
For convenience, we will compare the naive CD4^+^ T cells, which were analysed 
in the previous section to activated CD4^+^ T cells of the same dataset 
[@Martinez-jimenez2017]. Naive CD4^+^ T cells were activated for 3 hours 
using plate-bound CD3e and CD28 antibodies.
T cell activation is linked to strong transcriptional shifts and the
up-regulation of lineage specific marker genes, such as Tbx21 and Gata1 
*TODO ref, ref*.
To generate this data, the authors did not add cytokines, which are needed for 
T cell differentiations *TODO: ref*, meaning that any heterogeneity in the activated 
cell population does not arise from cells residing in different lineage-specific 
differentiation states. Prior to differential testing, and as explained above, 
we need to generate a `SingleCellExperiment` object that is compatible for
processing using `BASiCS`.

### Creating the BASiCS Data objects

We have performed quality control on the naive and activated CD4^+^ T cells 
above when [preparing the `BASiCS_Data` object](#Tcells-filtering).
Therefore, we can directly select the 
activated CD4^+^ T cells from the `sce_naive_active` object.

```{r SCE-active}
ind_active <- sce_naive_active$Stimulus == "Active"
sce_active <- sce_naive_active[, sce_naive_active$Stimulus == "Active"]
```

Similar to the procedure described above in the 
[single condition example](#Tcells-single), we will use 
the `newBASiCS_Data` function to re-generate the `SingleCellExperiment` object 
for the use with BASiCS.

```{r Data-active}
## select the biological genes of the dataset
counts <- counts(sce_active)
## Select the ERCC spike-ins of the dataset
spikes <- assay(altExp(sce_active, "spike-ins"))
spikes_present <- rowSums(spikes) != 0
## Remove spike-ins that are not present from matrix and SCE object
spikes <- spikes[spikes_present, ]
altexp_present <- altExp(sce_active, "spike-ins")[spikes_present, ]
altExp(sce_active, "spike-ins") <- altexp_present
ind_spike <- c(rep(FALSE, nrow(counts)), rep(TRUE, nrow(spikes)))
spike_input <- ERCC_count[rownames(spikes), ]


# Generate the SingleCellExperiment object
data_active <- newBASiCS_Data(
  Counts = rbind(counts, spikes),
  Tech = ind_spike,
  SpikeInfo = spike_input,
  BatchInfo = sce_active$Individuals
)

## Subset to common genes with naive
data_active <- data_active[rownames(data_naive)]
```

### Running the MCMC

We can use this `SingleCellExperiment` object as an input to `BASiCS_MCMC`
and run the MCMC sampler over 40,000 iterations.

```{r MCMC-active, eval = FALSE}
MCMC_active <- BASiCS_MCMC(
  Data = data_active,
  PrintProgress = FALSE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE
)
```

This sampler runs for *98 minutes* on a 1.4 GHz Intel Core i5 processor with 
4GB RAM and produces a `BASiCS_Chain` data object.
The same sampling run completed in *59 minutes* on a 3.4 GHz Intel Core i7 
processor with 16GB RAM.
For convenience, this MCMC chain can be again obtained online at 
[https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/](https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/).


```{r download-chain-active}
download_file(
  file = "MCMC_active.rds",
  website = "https://git.ecdf.ed.ac.uk/vallejosgroup/",
  folder = "basicsworkflow2020/raw/master/MCMCs/",
  destfile = "rds/MCMC_active.rds"
)
MCMC_active <- readRDS("rds/MCMC_active.rds")
```

### Quality checks

Similar to the `BASiCS_Chain` quality checks described above, we will again 
profile the convergence of the chain using a visual inspection of the trace 
plots, sample histograms and autocorrelation of individual chains.
Furthermore, we will use the `BASiCS_DiagPlot` function to assess the 
effective sample size of all chains per parameter class.

```{r convergence-active}
# Convergence of mean expression parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "mu", Gene = 1)
plot(MCMC_active, Param = "mu", Gene = 1000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "mu")

# Histogram of effective sample size for mu, as some genes seem to have low values for mu.
BASiCS_DiagHist(MCMC_active, Param = "mu")

# Convergence of over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "delta", Gene = 100)
plot(MCMC_active, Param = "delta", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "delta")

# Convergence of residual over-dispersion parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "epsilon", Gene = 200)
plot(MCMC_active, Param = "epsilon", Gene = 5000)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "epsilon")

# Convergence of mRNA capture efficiency parameters
# Trace plot, sample histogram and autocorrelation
plot(MCMC_active, Param = "s", Cell = 10)
plot(MCMC_active, Param = "s", Cell = 50)

# Effective sample size
BASiCS_DiagPlot(MCMC_active, Param = "s")
```

To highlight the regression trend, we can use the `BASiCS_ShowFit` function.

```{r active-fit}
BASiCS_ShowFit(MCMC_active)
```

The MCMC sampler converged and the regression captured the full range of 
data points similar to the regression done on naive CD4^+^ T cells.
We can therefore move on to perform differential testing between naive and 
activated CD4^+^ T cells.

## Differential testing

```{r convergence-ess}
BASiCS_DiagHist(MCMC_active, Param = "mu")
BASiCS_DiagHist(MCMC_active, Param = "delta")

BASiCS_DiagPlot(MCMC_active, Param = "mu")
BASiCS_DiagPlot(MCMC_active, Param = "delta")
```

### Differential mean expression

To perform robust differential mean expression testing, BASiCS removes
genes with small effective sample size from EFDR calibration and 
differential expression testing.
As explained [above](#naive-convergence), this 
can be done using functions from the `CRANpkg(coda)` package.

In total, we exlude 238 genes from testing due to low effective sample size 
when sampling the posterior distribution.

The default settings for differential mean expression testing are as follows:

`EpsilonM`: Log~2~ fold change (LFC) threshold for changes in mean expression: 
$\log_2(1.5)\approx0.41$
`EFDR_M`: Expected false discovery rate: 10%
`Plot`, `PlotOffset`: Boolean to control if results are plotted: TRUE

```{r mean-expression-testing}

# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(1.5),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
```

After running the test, we can now visaulize the results in form of a MA-plot 
(log ratio _versus_ mean average) and volcano plot (posterior probability
_versus_ log ratio).

```{r visualize-MA-plot}
colour_map <- c(
  "Naive+" = "dark blue",
  "Active+" = "dark red",
  "NoDiff" = "black",
  "ExcludedLowESS" = "grey60",
  "ExcludedByUser" = "grey80"
)
Test_DE$TableMean$ResultDiffMean <- factor(
  Test_DE$TableMean$ResultDiffMean,
  levels = names(colour_map)
)
Test_DE$TableMean <- Test_DE$TableMean[order(Test_DE$TableMean$ResultDiffMean), ]
colour_scale <- scale_color_manual(values = colour_map)
# Visualize MA plot
ggplot(Test_DE$TableMean) +
  geom_point(
    aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  colour_scale
# Visualize MA plot
ggplot(Test_DE$TableMean) +
  geom_point(
    aes(MeanLog2FC, ProbDiffMean, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  colour_scale
```

As we can see for the comparison of naive and activated CD4^+^ T cells, most 
genes show strong differences in mean expression.
In such cases, it can be beneficial to increase the LFC threshold or to 
decrease the threshold for the EFDR.
Here, we therfore set the LFC threshold to $\log_2(2)=1$ to detect genes 
with strong changes in mean expression. We also set `MinESS` to 100. This
causes genes with effective sample size less than 100 in either input chain
to be excluded from EFDR calibration and differential expression testing.
In this case, this results in 249 genes with low effective sample size
being excluded.

```{r mean-expression-testing-2}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
table(Test_DE$TableMean$ResultDiffMean)
```

To understand the regulatory programmes that underlie T cell activation, a 
variety of downstream analyses can be peformed using the differentially 
expressed genes.
Here, we highlight the use of gene ontology (GO) analysis to group genes that 
are differentially expressed between naive and activated CD4^+^ T cells.
For this, we use the Bioconductor `Biocpkg(goseq)` package and the 
`Biocpkg(org.Mm.eg.db)` annotation package to test GO enrichment within 
genes specifically expressed by naive or activated CD4^+^ T cells

```{r go-analysis-naive}

# Collect significan genes as 1 and all other as 0
naive_genes <- as.integer(Test_DE$TableMean$ResultDiffMean == "Naive+")
names(naive_genes) <- Test_DE$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(naive_genes, "mm10", "ensGene",
  bias.data = genenames[names(naive_genes), "gene_length"]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
naive_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(naive_GO))
for (i in 1:nrow(naive_GO)) {
  allegs <- get(naive_GO$category[i], org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes <- as.character(intersect(
    genes,
    Test_DE$TableMean$GeneName[naive_genes == 1]
  ))
  all_genes[i] <- paste(genenames[genes, "external_gene_name"],
    collapse = ", "
  )
}
naive_GO$gene <- all_genes

# Show GO categories
head(naive_GO$term, n = 10)
```

Genes that are down-regulated during immune activation are enriched for cell
surface receptor signalling related categories.
This is in line with the well-known down-regulation of the T-cell receptor 
(TCR) complex upon activation [@Borroto2000].
Here, we find components of the TCR complex (such as _Cd28_, _Cd3e_, _Cd3g_,
_Cd4_; all part of the 'cell surface receptor signaling pathway' GO category) 
to show higher expression in naive cells compared to activated CD4^+^ T cells.

We can also test the enrichment of GO categories among genes that show 
increased expression upon T cell activation.

```{r go-analysis-active}
# Collect significan genes as 1 and all other as 0
active_genes <- as.integer(Test_DE$TableMean$ResultDiffMean == "Active+")
names(active_genes) <- Test_DE$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(active_genes, "mm10", "ensGene",
  bias.data = genenames[names(active_genes), "gene_length"]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
active_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(active_GO))
for (i in 1:nrow(active_GO)) {
  allegs <- get(active_GO$category[i], org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.egENSEMBL)))
  genes <- as.character(intersect(
    genes,
    Test_DE$TableMean$GeneName[active_genes == 1]
  ))
  all_genes[i] <- paste(genenames[genes, "external_gene_name"],
    collapse = ", "
  )
}
active_GO$gene <- all_genes

# Show GO categories
head(active_GO$term, n = 10)
```

Genes that are up-regulated upon activation are dominated by GO categories that
are associated to translational and metabolic processes. 
It has been shown that within the first 24 hours of T cell activation, cells 
start to up-regulate components involved in translation, ribosome biogenesis 
and profileration [@Tan2017,@Araki2017]. 
This signature can be recovered by performing differential mean expression 
analysis between naive and activated CD4^+^ T cells.

While other computational tools exists to perform differential mean expression
analysis, we next want to highlight the use of BASiCS for differential 
variability testing.

### Differential over-dispersion

Due to the negative association between the over-dispersion and mean expression 
parameters, only genes that do not show a change in mean expression.
To avoid any mean expression confounding effect, we perform the differential 
testing by setting the LFC threshold on mean expression to `EpsilonM = 0` while 
using the default LFC threshold on changes in over-dispersion: 
`EpsilonD = log2(1.5)`.
We furthermore, it is crucial to exclude lowly expressed genes from this 
analysis to avoid biases arising from non-informative genes.

```{r over-dispersion-testing}
# Select genes that show expression in both conditions
genes_select <- (Test_DE$TableMean$Mean1 > 1 & Test_DE$TableMean$Mean2 > 1)

Test_DE_LFC0 <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = 0,
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100,
  GenesSelect = genes_select
)
```

We first select the genes that remain similarly expressed between both 
conditions and highligh the differential over-dispersion results in form of MA- 
and boxplots.

```{r over-dispersion-result}
# Select genes with no changes in mean expression
ind_nochange <- Test_DE_LFC0$TableMean$ResultDiffMean == "NoDiff"

# MA plot
ggplot(Test_DE_LFC0$TableDisp[ind_nochange, ]) +
  geom_point(
    aes(
      log(MeanOverall),
      DispLog2FC,
      colour = ResultDiffDisp
    ),
    shape = 16,
    alpha = 0.5
  ) +
  scale_color_manual(
    values = c(
      "Naive+" = "dark blue",
      "Active+" = "dark red",
      "NoDiff" = "black"
    )
  )

# Boxplot
wilcox.test(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange])
boxplot(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange],
  ylab = "LFC in over-dispersion", outline = FALSE
)
abline(a = 0, b = 0, lwd = 2, col = "dark red")

wilcox.test(Test_DE_LFC0$TableDisp$DispLog2FC[ind_nochange])
```

With this analysis, we detect increased over-dispersion in naive CD4^+^ T cells
for genes that show similar expression levels between naive and activated 
CD4^+^ T cells.

### Differential residual over-dispersion

While the analysis in the previous section is well suited to detect global 
changes in variability (e.g. detecting if one cell population overall displays
higher expression variabilty), it does not allow the testing of changes in 
mean expression and expression variability in parallel.
For this, BASiCS compares the residual over-dispersion parameters, which do 
not scale with mean expression, between the two conditions.
Here, we filter on genes that are lowly expressed in both conditions and, as 
explained above, remove genes for with the MCMC sampler leads to a low 
effective sample size:

```{r res-over-disp-filtering}
# Remove lowly expressed genes
low_expr <- !(Test_DE$TableMean$Mean1 < 1 & Test_DE$TableMean$Mean2 < 1)

# Genes to exclude
genes_select <- low_expr
```

We can now perform the differential testing as shown above.
Again, we use a LFC threshold higher than the default to capture strong changes
in mean expression.

```{r DE-DV-testing}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = MCMC_naive,
  Chain2 = MCMC_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  CheckESS = TRUE,
  MinESS = 100,
  Plot = FALSE,
  PlotOffset = FALSE,
  GenesSelect = genes_select
)
```

We can now visualize the changes in residual over-dispersion between naive and 
activated CD4^+^ T cells in form of a MA-plot.
In this visualization, the difference between the posterior medians of the 
residual over-dispersion parameters $\epsilon$ is shown on the y-axis.
Epsilon values for genes that are not expressed in at least 2 cells per 
conditions are marked as `NA` and are therefore not being displayed.

```{r diff-res-plot}
colour_map <- c(
  "Naive+" = "dark blue",
  "Active+" = "dark red",
  "NoDiff" = "black",
  "ExcludedByUser" = "grey",
  "ExcludedLowESS" = "grey80",
  "ExcludedFromTesting" = "grey50"
)
Test_DE$TableResDisp$ResultDiffResDisp <- factor(
  Test_DE$TableResDisp$ResultDiffResDisp,
  levels = names(colour_map)
)
Test_DE$TableResDisp <- Test_DE$TableResDisp[order(Test_DE$TableResDisp$ResultDiffResDisp), ]
ggplot(Test_DE$TableResDisp) +
  geom_point(
    aes(
      x = log(MeanOverall),
      y = ResDispDistance,
      colour = ResultDiffResDisp
    ),
    shape = 16,
    alpha = 0.5
  ) +
  scale_color_manual(values = colour_map)
```

While one could perform GO analysis (as explained above) on the genesets that 
change in residual over-dispersion, here, we want to highlight how to analyse 
changes in mean expression in parallel to changes in variability.
For this, we will first combine the results of the differential mean expression 
and the differential residual over-dispersion test.
We will further remove the genes that were excluded from the test and those 
that are not expressed in at least 2 cells in either condition.

```{r combine-results}
res.df <- cbind(Test_DE$TableMean, Test_DE$TableResDisp[, -c(1, 2)])
ind_exclude <- res.df$ResultDiffResDisp == "ExcludedByUser" |
  res.df$ResultDiffResDisp == "ExcludedFromTesting"
res.df <- res.df[!ind_exclude, ]
```

Next, we can visualize the regulation of each individual gene based on its 
changes in mean expression and expression variability.

```{r DV-DE-vis}
res.df$ResultDiffMean[grep("Excluded", res.df$ResultDiffMean)] <- "NoDiff"
res.df$ResultDiffResDisp[grep("Excluded", res.df$ResultDiffResDisp)] <- "NoDiff"
ggplot(res.df) +
  geom_point(
    aes(
      MeanLog2FC,
      ResDispDistance,
      colour = interaction(ResultDiffMean, ResultDiffResDisp, sep = ", ")
    ),
    alpha = 0.5,
    shape = 16
  ) +
  scale_color_brewer(name = "Categories", palette = "Set1")
```

While we can now test each of the nine genesets for functional enrichment, here, 
we are particularly interested in the set of genes that are up-regulated with 
increased variability upon immune activation.
Recently, it has been shown that specifically cytokines show heterogeneous 
expression in active immune cells and diverge between species [@Hagai2018].
We are therefore interested which immune response genes show variable activation 
patterns in early CD4^+^ T cell activation.
For this, we will first collect all immune response genes 
(GO category: `GO:0006955`) using the `goseq` package.

```{r variable-immune-response}
# Select immune response genes
immun.allegs <- get("GO:0006955", org.Mm.egGO2ALLEGS)
immun.genes <- unique(unlist(mget(immun.allegs, org.Mm.egENSEMBL)))
immun.names <- genenames[immun.genes, "external_gene_name"]
```

Finally, we will find the subset of immune response genes that are variably 
up-regulated upon early immune activation

```{r overlap}
# Variable response genes
ind_var.response <- res.df$ResultDiffMean == "Active+" &
  res.df$ResultDiffResDisp == "Active+"
var.response.genes <- genenames[
  res.df$GeneName[ind_var.response],
  "external_gene_name"
]
intersect(var.response.genes, immun.names)

ind_var.response <- res.df$ResultDiffMean == "Active+" &
  res.df$ResultDiffResDisp == "Naive+"
var.response.genes <- genenames[
  res.df$GeneName[ind_var.response],
  "external_gene_name"
]
intersect(var.response.genes, immun.names)
```

Pou2f2 and Smad3 .

While immune activation induces large transcriptional shifts in CD4^+^ T cells,
we will now exemplify the use of `BASiCS` on a system that shows more subtle
transcriptional changes during differentiation.




# Differential testing using differentiating cells (two group, droplet-based example) {#droplet-data}

With the development of droplet-based scRNA-Seq [@Klein2015, @Macosko2015] 
lead to a strong increase in the number of cells that can be profiled per 
experiment. 
With this, large-scale scRNA-Seq datasets have been generated to study 
development across multiple time-points and capturing musltiple tissues 
[@Ibarra-Soria2018, @Kernfeld2018]. 
Here we describe the computational analysis of changes in mean expression 
and transcriptional variability when data is sparse and technical spike-in 
genes are missing. 
For this, we compare cells of the presomitic mesoderm and somitic mesoderm 
using droplet-based scRNA-Seq data [@Ibarra-Soria2018].

## Obtaining the data

The full dataset is stored under the accession number E-MTAB-6153 on 
ArrayExpress and can be obtained via:

```{r load-droplet-data}
if (!file.exists("downloads/rawCounts.tsv")) {
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-6153/"
  file <- "E-MTAB-6153.processed.3.zip"
  download.file(
    paste0(website, folder, file),
    destfile = "downloads/rawCounts.zip"
  )
  unzip(zipfile = "downloads/rawCounts.zip", exdir = "downloads")
  unlink("downloads/rawCounts.zip")
}
rawCounts <- fread("downloads/rawCounts.tsv",
  sep = "\t", header = FALSE,
  data.table = FALSE
)

# Genenames are stored in first column
rownames(rawCounts) <- rawCounts[, 1]
rawCounts <- rawCounts[, -1]
```

*Of note:* The file is 65 MB in size while the unzipped, raw counts measure
873 MB in size.

The cluster labels of the original publication ca be obtained via:

```{r cluster-labels-droplet}
if (!file.exists("downloads/cellAnnotation.tsv")) {
  website <- "https://www.ebi.ac.uk/"
  folder <- "arrayexpress/files/E-MTAB-6153/"
  file <- "E-MTAB-6153.processed.3.zip"
  download.file(
    paste0(website, folder, file),
    destfile = "cluster_labels.zip"
  )
  unzip(zipfile = "cluster_labels.zip", exdir = "downloads")
}

cluster_labels <- read.table("downloads/cellAnnotation.tsv",
  sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

## Select populations of interest

We select the somitic and pre-somitic mesoderm cells to perform differential 
testing. Prior to running the MCMC, we want to control for outlying cells and 
heterogeneous substructure in both cell populations. 

```{r droplet-cell-selection}
ind_som <- which(cluster_labels$cellType == "presomiticMesoderm" |
  cluster_labels$cellType == "somiticMesoderm")
rawCounts <- rawCounts[, ind_som]
cluster_labels <- cluster_labels[ind_som, ]
```

## Generating SingleCellExperiment object and quality control

For pre-processing and visualization purposes, we load the data into a 
SingleCellExperiment object. The metadata will be stored in the `colData` slot.

```{r droplet-sce}
droplet_sce <- SingleCellExperiment(
  assays = list(counts = as(as.matrix(rawCounts), "dgCMatrix"))
)
rm(rawCounts)
colData(droplet_sce) <- DataFrame(
  cluster_labels,
  subCellType = sub("_.*", "", cluster_labels$cell)
)
```

For further processing steps, we remove lowly expressed genes.

```{r filter_drop}
ind_expressed <- Matrix::rowMeans(counts(droplet_sce)) > 0.1
droplet_sce <- droplet_sce[ind_expressed, ]
```

To visualize possible sub-structure in the data, we normalize both cell 
populations using the `scran` package.

```{r norm_drop}
droplet_sce <- computeSumFactors(droplet_sce,
  clusters = colData(droplet_sce)$subCellType
)
droplet_sce <- logNormCounts(droplet_sce)
```

Next, we compute a PCA using the `scater` package. 

```{r droplet_pca}
droplet_sce <- runPCA(droplet_sce)
```

We can now visualize the different factors stored in the `colData` slot.

```{r drop_pca_plot}
# Cell types identified by clustering
plotReducedDim(droplet_sce, dimred = "PCA", colour_by = "subCellType") +
  scale_fill_manual(name = "Cell type", values = c("coral4", "steelblue", "limegreen"))
```

The first PC separates the two different cell types while the second PC captures
outlying cells.
We will remove these outliers and the intermediate cell population from 
down-stream analysis.

```{r drop_filt}
ind_retain <- reducedDims(droplet_sce)$PCA[, 2] > -5 &
  colData(droplet_sce)$subCellType != "presomiticMesoderm.b"
droplet_sce <- droplet_sce[, ind_retain]
```

We now collected the cells that we want to process using BASiCS. 
For this, we will generate the BASiCS data objects.

## Generating BASiCS data objects

Since droplet-based scRNA-Seq data are generated without including technical 
spike-in genes, BASiCS uses measurement error models to quantify technical 
variation through replication [@Carroll1998].
Here, it is crucial to provide batch information to the BASiCS model.
In the case of the somitic and pre-somoitic mesoderm cells, embryos of two mice 
have been used to generate the data. 
Cells isolated from the first embryo were split into two batches and processed 
independently.
To capture cell-type extrinsic, biological variation between the two mice, we 
pool cells from the two batches of the first animal and only considere cells 
from mouse 1 and mouse 2 as replicates.

```{r BASiCS-droplet-data}
# Presomitic mesoderm
ind_presom <- colData(droplet_sce)$cellType == "presomiticMesoderm"
cur_counts <- droplet_sce[, ind_presom]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

PSM_Data <- newBASiCS_Data(
  Counts = as.matrix(counts(cur_counts)),
  Tech = rep(FALSE, nrow(droplet_sce)),
  SpikeInfo = NULL,
  BatchInfo = cur_batch
)

# Somitic mesoderm
ind_som <- colData(droplet_sce)$cellType == "somiticMesoderm"
cur_counts <- droplet_sce[, ind_som]
cur_batch <- round(colData(cur_counts)$sample, digits = 0)

SM_Data <- newBASiCS_Data(
  Counts = as.matrix(counts(cur_counts)),
  Tech = rep(FALSE, nrow(droplet_sce)),
  SpikeInfo = NULL,
  BatchInfo = cur_batch
)
```

## Running the MCMC

We next estimate model parameters by running the MCMC cell-type specifically. 
Due to the high cell number (1150 for the pre-somitic mesoderm and 739 for the 
somitic mesoderm), we set the number of iterations to 20000. 
In this case, we used the regression BASiCS model to additionally estimate residual 
over-dispersion parameters.

```{r, eval = FALSE}
# Presomitic mesoderm cells
PSM_MCMC <- BASiCS_MCMC(
  PSM_Data,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE
)

# Somitic mesoderm cells
SM_MCMC <- BASiCS_MCMC(
  SM_Data,
  N = 20000,
  Thin = 10,
  Burn = 10000,
  Regression = TRUE
)
```

Running these MCMC will take around 8-12 hours on a standard PC (2.6 GHz i5,
8 GB RAM, using 1 core). Here, we provide these chains to download from:

```{r droplet-chain-download}
website <- "https://git.ecdf.ed.ac.uk/"
folder <- "vallejosgroup/basicsworkflow2020/raw/master/MCMCs/"
PSM_MCMC <- readRDS(
  file = url(
    paste0(website, folder, "PSM_MCMC.rds")
  )
)
SM_MCMC <- readRDS(
  file = url(
    paste0(website, folder, "SM_MCMC.rds")
  )
)
```

## Validating the model fit

Next, we visualize the results of the MCMC sampler by visualizing the 
different chains and by plotting the regression trend.
To assess whether the chains converged, we will visualize trace plots for some 
of the parameters. 
The `mcmc` function of the `coda` package is suited to generate trace plots 
for each chain. 

```{r droplet-chain-convergence}
plot(PSM_MCMC, Param = "mu", Gene = 120)
plot(PSM_MCMC, Param = "delta", Gene = 10)
plot(PSM_MCMC, Param = "epsilon", Gene = 20)
plot(PSM_MCMC, Param = "s", Cell = 90)
plot(PSM_MCMC, Param = "nu", Cell = 100)
plot(PSM_MCMC, Param = "beta", RegressionTerm = 2)
plot(PSM_MCMC, Param = "sigma2", Column = 1)
plot(SM_MCMC, Param = "mu", Gene = 120)
plot(SM_MCMC, Param = "delta", Gene = 10)
plot(SM_MCMC, Param = "epsilon", Gene = 20)
plot(SM_MCMC, Param = "s", Cell = 90)
plot(SM_MCMC, Param = "nu", Cell = 100)
plot(SM_MCMC, Param = "beta", RegressionTerm = 2)
plot(SM_MCMC, Param = "sigma2")
```

We observe that the chains for all chosen paramteres converged. 
Furthermore, to validate that the model fitted the mean-variability trend 
correctly, we plot posterior estimates for over-dispersion paramters $\delta_i$ 
against posterior estimates of mean expression parameters $\mu_i$.
For this, the `BASiCS_ShowFit` function can be used.

```{r droplet-regression-trend}
BASiCS_ShowFit(PSM_MCMC)
BASiCS_ShowFit(SM_MCMC)
```

Both trends display similar behaviour which allows us to compare residual 
over-dispersion estimates.

## Differential testing 

Next, we test for changes in mean expression and expression variability 
between the somitic and pre-somitic mesoderm.
First, we are interested in assessing global changes in expression 
variability between the two conditions.
For this, over-dispersion paramters $\delta_i$ for genes that are similarly 
expressed in both conditions are compared.

```{r drop_testde_lfc0}
droplet_test_logFC0 <- BASiCS_TestDE(
  Chain1 = PSM_MCMC,
  Chain2 = SM_MCMC,
  EpsilonM = 0,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)
not_excluded <- droplet_test_logFC0$TableDisp$ResultDiffDisp != "ExcludedFromTesting"
for_plot <- droplet_test_logFC0$TableDisp[not_excluded, c("Disp1", "Disp2")]
for_plot <- reshape2::melt(for_plot)
ggplot(for_plot) + geom_boxplot(aes(variable, log(value))) +
  scale_x_discrete(labels = c("PSM", "SM")) +
  ylab("log(delta)") + xlab("")
```

### Global changes in variability

With this analysis, we do not detect global changes in expression variability.
We next profile changes in mean expression and expression variability on a 
gene-specific level.
For this, we use a log~2~ fold change threshold of 1 for mean expression testing 
and the default threshold of $\psi_0\approx0.41$ for differential variability 
testing.

```{r droplet-gene-specific-testing}
droplet_test <- BASiCS_TestDE(
  Chain1 = PSM_MCMC,
  Chain2 = SM_MCMC,
  EpsilonM = 1,
  GroupLabel1 = "PSM",
  GroupLabel2 = "SM",
  Plot = FALSE,
  PlotOffset = FALSE,
  CheckESS = TRUE,
  MinESS = 100
)


colour_map_sm <- c(
  "PSM+" = "dark blue",
  "SM+" = "dark red",
  "NoDiff" = "black",
  "ExcludedLowESS" = "grey60",
  "ExcludedByUser" = "grey80"
)

# Differential expression
ggplot(droplet_test$TableMean) +
  geom_point(
    aes(log(MeanOverall), MeanLog2FC, colour = ResultDiffMean),
    shape = 16,
    alpha = 0.5
  ) +
  scale_colour_manual(
    name = "Differential\nexpression",
    values = colour_map_sm
  ) +
  ylab(expression(mu[PSM] / mu[SM])) + xlab(expression(log(mu)))

# Differential variability
ggplot(droplet_test$TableResDisp) +
  geom_point(
    aes(log(MeanOverall), ResDispDistance, colour = ResultDiffResDisp),
    shape = 16,
    alpha = 0.5
  ) +
  scale_colour_manual(
    name = "Differential\nvariability",
    values = colour_map_sm
  ) +
  ylab(expression(epsilon[PSM] - epsilon[SM])) + xlab(expression(log(mu)))
```

### Differential mean expression

We can now list the genes that were detected as differenitally expressed and 
differentially variable ordered by their difference in mean 
expression/variability.
We first focus on genes that are differentially expressed between the two cell 
types.

```{r gene-lists-mean}
# Highly expressed in somitic mesoderm
ind_sm <- droplet_test$TableMean$ResultDiffMean == "SM+"
SM_mean <- droplet_test$TableMean[ind_sm, ]
SM_mean <- SM_mean[order(SM_mean$MeanLog2FC, decreasing = FALSE), ]
SM_mean$Symbol <- genenames[SM_mean$GeneName, 2]

# Highly expressed in pre-somitic mesoderm
ind_psm <- droplet_test$TableMean$ResultDiffMean == "PSM+"
PSM_mean <- droplet_test$TableMean[ind_psm, ]
PSM_mean <- PSM_mean[order(PSM_mean$MeanLog2FC, decreasing = TRUE), ]
PSM_mean$Symbol <- genenames[PSM_mean$GeneName, 2]
```

We can next perform GO analysis on up- or down-regulated genes. 
First, we will perform GO analysis on somitic mesoderm specific genes.

```{r GO-analysis-mean-SM}
# Collect significan genes as 1 and all other as 0
SM_genes <- as.integer(droplet_test$TableMean$ResultDiffMean == "SM+")
names(SM_genes) <- droplet_test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(SM_genes, "mm10", "ensGene", bias.data = genelength[names(SM_genes)])
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
SM_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(SM_GO))
for (j in 1:nrow(SM_GO)) {
  allegs <- get(SM_GO$category[j], org.Mm.eg.db::org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.eg.db::org.Mm.egENSEMBL)))
  genes <- as.character(intersect(genes, SM_mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
SM_GO$Genes <- all_genes
```

Now, we perform GO analysis on pre-somitic mesoderm specific genes

```{r GO-analysis-mean-PSM}
# Collect significan genes as 1 and all other as 0
PSM_genes <- as.integer(droplet_test$TableMean$ResultDiffMean == "PSM+")
names(PSM_genes) <- droplet_test$TableMean$GeneName

# Build a Null distribution by correcting the gene length bias
pwf <- nullp(
  PSM_genes,
  "mm10",
  "ensGene",
  bias.data = genelength[names(PSM_genes)]
)
GO_wall <- goseq(pwf, "mm10", "ensGene")
ind_signif <- p.adjust(GO_wall$over_represented_pvalue, method = "fdr") < 0.01
PSM_GO <- DataFrame(GO_wall[ind_signif, ])

# Add genenames to the GO categories
all_genes <- vector(length = nrow(PSM_GO))
for (j in 1:nrow(PSM_GO)) {
  allegs <- get(PSM_GO$category[j], org.Mm.eg.db::org.Mm.egGO2ALLEGS)
  genes <- unique(unlist(mget(allegs, org.Mm.eg.db::org.Mm.egENSEMBL)))
  genes <- as.character(intersect(genes, PSM_mean$GeneName))
  all_genes[j] <- paste(genes, collapse = ", ")
}
PSM_GO$Genes <- all_genes
```

To visualize the expression of individual genes, we can use the `scater` package.

```{r plot-de-scater}
# Expression of Fgf8 in both conditions
ind_fgf <- genenames$external_gene_name == "Fgf8"
plotExpression(droplet_sce,
  features = genenames[ind_fgf, 1],
  x = "cellType", colour_by = "cellType"
) + scale_fill_manual(name = "Cell type", values = c("coral4", "limegreen"))
plotReducedDim(droplet_sce,
  dimred = "PCA",
  colour_by = genenames[ind_fgf, 1]
)
```

Visualize one category in form of heatmap.

```{r gp-heatmap, fig.height = 7, fig.width = 5}
genes <- unlist(strsplit(PSM_GO[1, "Genes"], ", "))
for_heatmap <- logcounts(droplet_sce)[genes, ]
colnames(for_heatmap) <- colData(droplet_sce)$cell

# Order cells by cell type
for_heatmap <- for_heatmap[, order(colnames(for_heatmap))]

# Order rows by log2FC
heatmap_ind <- match(rownames(for_heatmap), PSM_mean$GeneName)
heatmap_order <- order(PSM_mean[heatmap_ind, "MeanLog2FC"], decreasing = TRUE)
for_heatmap <- for_heatmap[heatmap_order, ]

pheatmap(for_heatmap,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  cluster_rows = FALSE,
  color = colorRampPalette(c("#053061", "#4393c3", "white", "#d6604d", "#67001f"))(100),
  labels_row = genenames[rownames(for_heatmap), 2],
  cellheight = 8,
  fontsize = 7,
  annotation_col = data.frame(
    row.names = colnames(for_heatmap),
    cellType = sub("_.*", "", colnames(for_heatmap))
  ),
  scale = "row"
)
```


### Differential variability testing

Next, we are interested in genes that change in variability between the two 
cell types. To help interpretion of the result, we will split the genes into 
four categories. These include:

* More variable in SM, highly expressed in SM
* More variable in SM, lowly expressed in SM
* More variable in PSM, highly expressed in PSM
* More variable in PSM, lowly expressed in SM

```{r diff-var-check}
gene_groups <- data.frame(
  Genename = droplet_test$TableResDisp$GeneName,
  Symbol = genenames[droplet_test$TableResDisp$GeneName, 2],
  MeanLog2FC = droplet_test$TableMean$MeanLog2FC,
  ResDispDistance = droplet_test$TableResDisp$ResDispDistance,
  Regulation = paste(
    droplet_test$TableMean$ResultDiffMean,
    droplet_test$TableResDisp$ResultDiffResDisp,
    sep = "_"
  )
)

ind_reg <- gene_groups$Regulation %in% c("SM+_SM+", "SM+_PSM+", "PSM+_PSM+", "PSM+_SM+")
gene_groups <- gene_groups[ind_reg, ]

knitr::kable(head(gene_groups[gene_groups$Regulation == "SM+_SM+", ]))
```

We can visualize individual genes using `scater`.

```{r violin-plots}
# Expression of Meox2 in both conditions
ind_meox <- genenames$external_gene_name == "Meox2"
plotExpression(droplet_sce,
  features = genenames[ind_meox, 1],
  x = "cellType", colour_by = "cellType"
) + scale_fill_manual(name = "Cell type", values = c("coral4", "limegreen"))
plotReducedDim(droplet_sce,
  dimred = "PCA",
  colour_by = genenames[ind_meox, 1]
)
```

# Discussion 
This section is required if the paper does not include novel data or analyses.
It allows authors to briefly summarize the key points from the article.

# Session Info {#session-info}

```{r, session-info}
devtools::session_info()
```

# Software version

**TODO: Versions of all main Bioconductor packages**
*I think sessionInfo suffices.*



# Data availability

**TODO: Links to Grun data and Ximenas data**
**TODO: Links to MCMC chains**


# Software availability

**TODO: Software: All software used in this workflow is available as part of 
Bioconductor X.Y**
**TODO: The source code of this workflow is available from: YYY**
**TODO: Link to Github release version, source code**
**TODO: License: ask Aaron**

This section will be generated by the Editorial Office before publication. 
Authors are asked to provide some initial information to assist the 
Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder
  (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the 
  source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* 
  TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information
In order to give appropriate credit to each author of an article, the 
individual contributions of each author to the manuscript should be detailed in 
this section. We recommend using author initials and then stating briefly how 
they contributed.

# Competing interests

'No competing interests were disclosed'.

<!-- All financial, personal, or professional competing interests for any of the 
authors that could be construed to unduly influence the content of the article 
must be disclosed and will be displayed alongside the article. If there are no 
relevant competing interests to declare, please add the following: 
 -->

# Grant information
Please state who funded the work discussed in this article, whether it is your 
employer, a grant funder etc. Please do not list funding that you have that is 
not relevant to this specific piece of research. For each funder, please state 
the funder’s name, the grant number where applicable, and the individual to 
whom the grant was assigned. If your work was not funded by any grants, 
please include the line: 'The author(s) declared that no grants were involved 
in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the 
article but who does not qualify as an author based on the criteria provided 
earlier (e.g. someone or an organization that provided writing assistance). 
Please state how they contributed; authors should obtain permission to 
acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.
