---
title: "BASiCS workflow: a step-by-step analysis of expression variability using single cell RNA sequencing data"
author: 
  - name: Alan O'Callaghan
    affiliation: 
    - &MRC MRC Human Genetics Unit, Institute of Genetics \& Molecular Medicine, 
      University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, 
      EH4 2XU, UK
    email: "a.b.o'callaghan@sms.ed.ac.uk"
  - name: Nils Eling
    affiliation: 
    - &UZH Department of Quantitative Biomedicine, University of Zurich,
      Winterthurerstrasse 190, CH-8057, Zurich, Switzerland
  - name: John C. Marioni
    affiliation: 
    - &EBI European Molecular Biology Laboratory, European Bioinformatics 
      Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
    - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
      Li Ka Shing Centre, Cambridge, CB2 0RE, UK
  - name: Catalina A. Vallejos
    affiliation: 
    - *MRC 
    - The Alan Turing Institute, British Library, 96 Euston Road, London, 
      NW1 2DB, UK
    email: catalina.vallejos@igmm.ed.ac.uk
abstract: |
  Cell-to-cell gene expression variability is an inherent feature of complex 
  biological systems, such as immunity and development. Single-cell RNA 
  sequencing is a powerful tool to quantify this heterogeneity, but it is prone 
  to strong technical noise. In this article, we describe a step-by-step 
  computational workflow that uses the BASiCS Bioconductor package to robustly 
  quantify expression variability within and between known groups of cells (such 
  as experimental conditions or cell types). BASiCS uses an integrated framework 
  for data normalisation, technical noise quantification and downstream 
  analyses, whilst propagating statistical uncertainty across these steps. 
  Within a single seemingly homogeneous cell population, BASiCS can identify 
  highly variable genes that exhibit strong heterogeneity as well as lowly 
  variable genes with stable expression. BASiCS also uses a probabilistic 
  decision rule to identify changes in expression variability between cell 
  populations, whilst avoiding confounding effects related to differences in 
  technical noise or in overall abundance. Using a publicly available 
  dataset, we guide users through a complete pipeline that includes 
  preliminary steps for quality control, as well as data exploration 
  using the scater and scran Bioconductor packages. Data for the case 
  study was generated using the Fluidigm\@ C1 system, in which extrinsic 
  spike-in RNA molecules were added as a control. The workflow is accompanied 
  by a Docker image that ensures the reproducibility of our results. 
keywords: Single-cell RNA sequencing, expression variability, 
  transcriptional noise, differential expression testing
bibliography: Workflow.bib
urlcolor: Orange
output:
  BiocWorkflowTools::f1000_article:
    fig_width: 6
    fig_height: 3.5
  BiocStyle::html_document:
    fig_width: 8
    fig_height: 4.5
---



```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
## Decide whether to display parts for BioC (TRUE) or F1000 (FALSE)
on.bioc <- FALSE
library("knitr")
library("ggplot2")
theme_set(theme_bw())
# Use fig.width = 7 for html and fig.width = 6 for pdf
# fig.width <- ifelse(on.bioc, 10, 6)
if (knitr::is_html_output()) {
  out_width <- "700px"
  out_height <- "600px"
} else if (knitr::is_latex_output()) {
  out_width <- "2.5in"
  out_height <- "3.5in"
}
knitr::opts_chunk$set(
  warning = FALSE, message = FALSE, error = FALSE,
  cache = 2, cache.path = "cache_main/",
  # fig.pos = "h",
  fig.path = "figure/"
)
```


# Introduction

<!--- scRNA-seq and the different types of heterogeneity ---> 
<!--- Nils to revisit and add additional references if required --->
Single-cell RNA-sequencing (scRNA-seq) enables the study of genome-wide 
transcriptional heterogeneity in cell populations that is not 
captured by bulk experiments [@Stegle2015; @Prakadan2017; @Patange2018]. 
On the broadest level, this heterogeneity can reflect the presence of distinct 
cell subtypes or states. 
Alternatively, it can be due to gradual changes along biological processes, 
such as development and differentiation. 
Several clustering and pseudotime inference methods have been developed to
characterise these types of heterogeneity [@Kiselev2019; @Saelens2019].
However, there is a limited availability of computational tools tailored 
to study more subtle variability within seemingly homogeneous cell populations. 
This variability can reflect deterministic or stochastic events that regulate
gene expression and, among others, has been reported to increase prior to cell
fate decisions [@Mojtahedi2016] as well as during ageing [@Martinez-jimenez2017]. 


Stochastic variability within a seemingly homogeneous cell population --- often 
referred to as transcriptional *noise* --- can arise from intrinsic and 
extrinsic sources [@Elowitz2002; @Eling2019]. 
Extrinsic noise refers to stochastic fluctuations induced by 
different dynamic cellular states (e.g. cell cycle, metabolism, 
intra/inter-cellular signalling) [@Zopf2013; @Iwamoto2016; @Kiviet2014]. 
In contrast, intrinsic noise arises from stochastic effects on biochemical 
processes such as transcription and translation [@Elowitz2002].
Intrinsic noise can be modulated by genetic and epigenetic modifications (such 
as mutations, histone modifications, CpG island length and nucleosome 
positioning) [@Eberwine2015; @Faure2017; @Morgan2018] and usually occurs 
at the gene level [@Elowitz2002]. 
Cell-to-cell gene expression variability estimates derived from scRNA-seq data 
capture a combination of these effects, as well as deterministic regulatory 
mechanisms [@Eling2019]. 
Moreover, these variability estimates can also be inflated by the technical 
noise that is typically observed in scRNA-seq data [@Brennecke2013].

<!--- Experimental strategies to tackle technical noise --->
Different strategies have been incorporated into scRNA-seq protocols to control 
or attenuate technical noise. 
For example, external RNA spike-in molecules (such as the set introduced by the 
External RNA Controls Consortium, ERCC [@Rna2005]) can be added to each cell’s 
lysate in a (theoretically) known fixed quantity.
Spike-ins can assist quality control steps [@McCarthy2017], data normalisation
[@Vallejos2017] and can be used to infer technical noise [@Brennecke2013].
Another strategy is to tag individual cDNA molecules using unique molecular 
identifiers (UMIs) before PCR amplification [@Islam2014]. 
Reads that contain the same UMI can be collapsed into a single molecule count,
attenuating technical variability associated to cell-to-cell differences
in amplification and sequencing depth (these technical biases are not fully 
removed unless sequencing to saturation [@Vallejos2017]). 
However, despite the benefits associated to the use of spike-ins and UMIs, 
these are not available for all scRNA-seq protocols [@Haque2017].

The Bioconductor package `r Biocpkg("BASiCS")` aims to account for these
sources of noise, both technical and biological. In particular, we
encourage the use of UMIs when performing a scRNAseq study.
It is well-established that scRNAseq data is distributed
according to a negative binomial distribution when UMIs are used in the 
sequencing protocol [@Svennson2020;@Townes2020;@Townes2019]. Thus, the
distributional assumptions of `r Biocpkg("BASiCS")` are more likely to be valid
for datasets wherein UMIs have been used. Furthermore, 
`r Biocpkg("BASiCS")` leverages spike-in molecules to aid in normalisation when
available, though a recent extension of the model allows the application of
the model in the absence of spike-in molecules [@Eling2018]. Moreover,
`r Biocpkg("BASiCS")` enables the quantification of variability within a 
population, while accounting for the overall mean-variance relationship in
an scRNAseq dataset [@Eling2018].


<!--- Describes aims for the workflow and introduces BASiCS ---> 
This article complements existing scRNA-seq workflows based on the Bioconductor 
ecosystem (e.g. [@Lun2016; @Kim2019]), providing a detailed framework for 
transcriptional variability analyses. 
Firstly, we describe a step-by-step workflow that uses
`r Biocpkg("scater")` [@McCarthy2017] and `r Biocpkg("scran")` [@Lun2016] 
to perform quality control (QC) as well as initial exploratory analyses. 
To robustly quantify transcriptional variability we use `r Biocpkg("BASiCS")` 
[@Vallejos2015; @Vallejos2016; @Eling2017] --- a Bayesian hierarchical framework 
that jointly performs data normalisation, technical noise quantification and 
downstream analyses, whilst propagating statistical uncertainty across these 
steps. 
Our analysis pipeline includes practical guidance to assess the convergence of 
the Markov Chain Monte Carlo (MCMC) algorithm that is used to infer model 
parameters as well as recommendations to interpret and post-process the model 
outputs. 
Finally, through a case study in the context of immune cells, we illustrate
how `r Biocpkg("BASiCS")` can be used to identify highly and lowly variable
genes within a cell population, as well as to compare expression profiles
between experimental conditions or cell types. 

All source code used to generate the results presented in this article is 
available [on Github](https://github.com/VallejosGroup/BASiCSWorkflow).
To ensure the 
reproducibility of this workflow, the analysis environment and all software 
dependencies are provided as a Docker image [@Boettiger2015]. The image 
can be obtained from
[Docker Hub](https://hub.docker.com/repository/docker/alanocallaghan/bocker).


# Methods {#methods}

This step-by-step scRNA-seq workflow is primarily based on the Bioconductor 
package ecosystem [@Amezquita2019]. 
A graphical overview is provided in Figure \@ref(fig:overview) 
and its main components are described below. 

```{r overview, out.width=out_width, out.height=out_height, fig.cap = 'Graphical overview for the scRNA-seq analysis workflow described in this manuscript. Starting from a matrix of expression counts, we use the scater and scran Bioconductor packages to perform QC and initial exploratory analyses. To robustly quantify transcriptional heterogeneity within seemingly homogeneous cell populations, we apply the BASiCS Bioconductor package and  illustrate how BASiCS can be used to analyse a single or multiple pre-specified groups of cells.', echo=FALSE}
knitr::include_graphics("figure/Overview.png")
```


### Input data

```{r}
library("SingleCellExperiment")
```

We use `r Biocpkg("SingleCellExperiment")` to convert an input
matrix of raw read-counts (molecule counts for UMI-based protocols) into a 
`SingleCellExperiment` object that can also store its associated 
metadata, such as gene- and cell-specific information. 
Moreover, when available, the same object can also store read-counts for 
spike-in molecules (see `?altExp`).
A major advantage of using a `SingleCellExperiment` object as the input for 
scRNA-seq analyses is the interoperability across a large number of 
Bioconductor packages [@Amezquita2019]. 

## QC and exploratory data analysis

```{r}
library("scater")
library("scran")
```

An critical step in scRNA-seq analyses is QC, removing low quality samples that 
may distort downstream analyses. 
In this step, we use QC diagnostics to identify and remove samples that 
correspond to broken cells, that are empty, or that contain multiple cells 
[@Ilicic2016]. We  also typically remove lowly expressed genes that represent 
less reliable information. 
The [*OSCA*](https://osca.bioconductor.org/) online book provides an extensive
overview on important aspects of how to perform QC of scRNA-seq data, including
exploratory analyses [@Amezquita2019].

Here, we use the `r Biocpkg("scater")` package [@McCarthy2017] to calculate 
QC metrics for each cell (e.g. total read-count) and gene (e.g. percentage of 
zeroes across all cells), respectively. 
Moreover, we use the visualisation tools implemented in `r Biocpkg("scater")` to 
explore the input dataset and its associated QC diagnostic metrics. 
For further data exploration we use the `r Biocpkg("scran")` package [@Lun2016].
`r Biocpkg("scran")` can perform *global scaling* normalisation, calculating 
cell-specific scaling factors that capture global differences in read-counts 
across cells (e.g. due to sequencing depth and PCR amplification) 
[@Lun2016pooling]. 
Moreover, `r Biocpkg("scran")` enables exploratory analyses of transcriptional
variability. 
For example, it can be used to infer an overall trend between mean expression 
and the squared coefficent of variation (CV^2^) for each gene. 
To derive variability estimates that are not confounded by this overall trend, 
`r Biocpkg("scran")` also defines gene-specific DM (distance to the mean) 
estimates as the distance between CV$^2$ and a rolling median along the range 
of mean expression values [@Kolodziejczyk2015cell].
DM estimates enable exploratory analyses of cell-to-cell heterogeneity, but a
measure of uncertainty is not readily available. As such, gene-specific 
downstream inference (e.g. differential variability testing) is precluded.


## BASiCS - Bayesian Analysis of Single Cell Sequencing data

```{r}
library("BASiCS")
```

The `r Biocpkg("BASiCS")` package uses a Bayesian hierarchical framework 
that borrows information across all genes and cells to robustly quantify 
transcriptional variability [@Vallejos2015BASiCS].
Similar to the approach adopted in `r Biocpkg("scran")`, `r Biocpkg("BASiCS")` 
infers cell-specific global scaling normalisation parameters. 
However, instead of inferring these as a pre-processing step, 
`r Biocpkg("BASiCS")` uses an integrated approach wherein data normalisation 
and downstream analyses are performed simultaneously, thereby propagating
statistical uncertainty. 
To quantify technical noise, the original implementation of 
`r Biocpkg("BASiCS")` uses information from extrinsic spike-in molecules as 
control features, but the model has been extended to address situations wherein
spike-ins are not available [@Eling2018].

`r Biocpkg("BASiCS")` summarises the expression pattern for each gene through 
gene-specific *mean* and *over-dispersion* parameters. 
Mean parameters $\mu_i$ quantify the overall expression for each gene $i$
across the population of cells under study.
In contrast, $\delta_i$ captures the excess of variability that is observed with 
respect to what would be expected in a homogeneous cell population, after 
taking into account technical noise. 
This is used as a proxy to quantify transcriptional variability.
To account for the strong relationship that is typically observed 
between gene-specific mean expression and over-dispersion estimates, 
Eling *et al.*  [@Eling2018] recently introduced a joint prior specification for 
these parameters. 
This joint prior formulation has been observed to improve posterior inference
when the data is less informative (e.g. small sample size, lowly expressed 
genes), borroring information across all genes to infer an overall trend that
captures the relationship between mean and over-dispersion values.
The trend is subsequently used to derive gene-specific *residual over-dispersion* 
parameters $\epsilon_i$ that are not confounded by mean expression. 
Similar to DM values implemented in `r Biocpkg("scran")`, these are defined as 
deviations with respect to an overall regression trend .

Within a population of cells, `r Biocpkg("BASiCS")` decomposes the total 
observed variability in expression measurements into technical and biological 
components [@Vallejos2015]. 
This enables the identification of *highly variable genes* (HVGs) that capture
the major sources of heterogeneity within the analysed cells [@Brennecke2013]. 
HVG detection is often used as feature selection, to identify the input 
set of genes for subsequent analyses. 
`r Biocpkg("BASiCS")` can also highlight *lowly variable genes* (LVGs) that 
exhibit stable expression across the population of cells.
These may relate to essential cellular functions and can assist the development
of new data normalisation or integration strategies [@Lin2019].

`r Biocpkg("BASiCS")` also provides a probabilistic decision rule to 
perform differential expression analyses between two (or more) pre-specified 
groups of cells [@Vallejos2016; @Eling2018].
While several differential expression tools have been proposed for scRNA-seq 
data (e.g. [@Kharchenko2014; @Finak2015]), some evidence suggests that 
these do not generally outperform popular bulk RNA-seq tools [@Soneson2018]. 
Moreover, most of these methods are only designed to uncover changes in overall
expression, ignoring the more complex patterns that can arise at the single cell 
level [@Lahnemann2020]. 
Instead, `r Biocpkg("BASiCS")` embraces the high granularity of scRNA-seq data,
uncovering changes in cell-to-cell expression variability that are not 
confounded by differences in technical noise or in overall expression.

# Case study: analysis of naive CD4^+^ T cells {#Tcells}

As a case study, we use scRNA-seq data generated for CD4^+^ T cells
using the C1 Single-Cell Auto Prep System (Fluidigm^®^). 
Martinez-Jimenez _et al._ profiled naive (hereafter also referred to as 
unstimulated) and activated (3 hours using _in vitro_ antibody stimulation) 
CD4^+^ T cells from young and old animals across two mouse strains to study 
changes in expression variability during ageing and upon immune activation 
[@Martinez-jimenez2017].
They extracted naive or effector memory CD4^+^ T cells from spleens of young or 
old animals, obtaining purified populations using either magnetic-activated cell 
sorting (MACS) or fluorescence activated cell sorting (FACS).
External ERCC spike-in RNA [@Rna2005] was added to aid the quantification of 
technical variability across all cells and all experiments were performed in 
replicates (hereafter also referred to as batches).

## Downloading the data

The matrix with raw read counts can be obtained from ArrayExpress under the 
accession number 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
In the matrix, column names contain library identifiers and row names
display gene Ensembl identifiers. 

```{r naive-data}
if (!file.exists("downloads/raw_data.txt")) {
  website <- "https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4888/"
  file <- "E-MTAB-4888.processed.1.zip"
  download.file(
    paste0(website, file),
    destfile = "downloads/raw_data.txt.zip"
  )
  unzip("downloads/raw_data.txt.zip", exdir = "downloads")
  file.remove("downloads/raw_data.txt.zip")
}

CD4_raw <- read.table("downloads/raw_data.txt", header = TRUE, sep = "\t")
CD4_raw <- as.matrix(CD4_raw)
```

The input matrix contains data for `r format(ncol(CD4_raw), big.mark=",")`
cells and `r format(nrow(CD4_raw), big.mark=",")`
genes (including `r sum(grepl("ERCC", rownames(CD4_raw)))` ERCC spike-ins). 
Information about experimental conditions and other metadata is available 
under the same accession number. 

```{r selecting-serum-cells}
if (!file.exists("downloads/metadata_file.txt")) {
  website <- "https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4888"
  file <- "E-MTAB-4888.additional.1.zip"
  download.file(
    paste0(website, file),
    destfile = "downloads/metadata.txt.zip"
  )
  unzip("downloads/metadata.txt.zip", exdir = "downloads")
  file.remove("downloads/metadata.txt.zip")
}

CD4_metadata <- read.table(
  "downloads/metadata_file.txt",
  header = TRUE,
  sep = "\t"
)

# Save sample identifiers as rownames
rownames(CD4_metadata) <- CD4_metadata$X
```

The columns in the metadata file contain library identifiers (`X`), strain 
information (`Strain`; *Mus musculus castaneus* or *Mus musculus domesticus*), 
the age of the animals (`Age`; young or old), stimulation state of the cells 
(`Stimulus`; naive or activated), batch information (`Individuals`; associated 
to different mice), and cell type information (`Celltype`; via FACS or MACS 
purification). 

Here, we convert the data and metadata described above into a 
`SingleCellExperiment` object. 
For this purpose, we first separate the input matrix of expression counts into
two matrices associated to intrinsic genes and external spike-ins, respectively. 
Within the `SingleCellExperiment` object, the latter is stored separately
as an alternative experiment (see `?altExp`).

```{r CD4-SCE-object}
# Separate intrinsic from ERCC counts
bio_counts <- CD4_raw[!grepl("ERCC", rownames(CD4_raw)), ]
spike_counts <- CD4_raw[grepl("ERCC", rownames(CD4_raw)), ]
# Generate the SingleCellExperiment object
sce_CD4_all <- SingleCellExperiment(
  assays = list(counts = as.matrix(bio_counts)),
  colData = CD4_metadata[colnames(CD4_raw), ]
)
# Add read-counts for spike-ins as an alternative experiment
altExp(sce_CD4_all, "spike-ins") <- SummarizedExperiment(
  assays = list(counts = spike_counts)
)
```

Hereafter, our analysis focuses on naive and activated CD4^+^ T cells obtained 
from young *Mus musculus domesticus* animals, purified using MACS-based cell sorting. 
Here, we extract these 
`r sum(sce_CD4_all$Strain == "Mus musculus domesticus" & sce_CD4_all$Age == "Young" & sce_CD4_all$Celltype == "MACS-purified Naive")` samples.

```{r naive-activated-CD4-SCE-object}
ind_select <- sce_CD4_all$Strain == "Mus musculus domesticus" &
  sce_CD4_all$Age == "Young" &
  sce_CD4_all$Celltype == "MACS-purified Naive"
sce_naive_active <- sce_CD4_all[, ind_select]
sce_naive_active
```

## QC and exploratory data analysis

The data available at 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/) have
been already filtered to remove poor quality samples.
The QC applied in [@Martinez-jimenez2017] removed cells with: (i) fewer 
than 1,000,000 total reads, (ii) less than 20% of reads mapped to 
endogenous genes, (iii) less than 1,250 or more than 3,000 detected genes and 
(iv) more than 10% or fewer than 0.5% of reads mapped to mitochondrial genes.
As an illustration, we visualise some of these metrics. 
We also include another widely used QC diagnostic plot that compares the total 
number (or fraction) of spike-in counts versus the total number (or fraction) of 
endogeneous counts.
In such a plot, low quality samples are characterised by a high fraction of 
spike-in counts and a low fraction of endogeneous counts 
(see Figure \@ref(fig:PerCellQC)).

```{r PerCellQC, fig.cap="Cell-level QC metrics. The total number of endogenous read-counts (excludes non-mapped and intronic reads) is plotted against the total number of detected genes (left) and the total number of spike-in read-counts (right)."}
# Calculate and plot per cell QC metrics
sce_naive_active <- addPerCellQC(sce_naive_active, use_altexps = TRUE)
p_cellQC1 <- plotColData(
  sce_naive_active, 
  x = "sum", 
  y = "detected") +
  xlab("Total engogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(axis.text.x = element_text(hjust = 1, angle = 45))
p_cellQC2 <- plotColData(
  sce_naive_active, 
  x = "sum", 
  y = "altexps_spike-ins_sum") +
  xlab("Total engogenous reads per cell") +
  ylab("Total spike-in reads per cell") +
  theme(axis.text.x = element_text(hjust = 1, angle = 45))
multiplot(p_cellQC1, p_cellQC2, cols = 2)
```

We can also visualise these metrics with respect to cell-level metadata, such
as the experimental conditions (active vs unstimulated) and the different mice 
that cells were collected from 
(see Figure \@ref(fig:experimental-condition-batch)). 

```{r experimental-condition-batch, fig.cap="Cell-level QC metrics according to cell-level metadata. The total number of endogenous reads (excludes non-mapped and intronic reads) is plotted against the total number of detected genes. Colour indicates the experimental condition (left) and animal of origin (right) for each cell."}
p_stimulus <- plotColData(
    sce_naive_active,
    x = "sum",
    y = "detected", 
    colour_by = "Stimulus") +
  xlab("Total engogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1))
p_batch <- plotColData(
    sce_naive_active,
    x = "sum",
    y = "detected", 
    colour_by = "Individuals") +
  xlab("Total engogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1))
multiplot(p_stimulus, p_batch, cols = 2)
```

To further explore the underlying structure of the data, we compute global
scaling normalisation factors using `r Biocpkg("scran")` and perform a 
principal component analysis (PCA) of log-transformed normalised expression 
counts using `r Biocpkg("scater")`.
As seen in Figure \@ref(fig:pca-visualisation-stimulus-batch), this analysis 
suggests the absence of strong batch effects.
It should be noted that `r Biocpkg("scran")` normalisation
is not strictly necessary in the `r Biocpkg("BASiCS")` workflow and we only
use it here as part of the exploratory data analysis.
Moreover, count-based models for dimensionality reduction (e.g. [@Townes2019;@Lopez2018]) could be used as an alternative to PCA, 
removing the need for log normalisation .

```{r pca-visualisation-stimulus-batch, fig.cap="First two principal components of log-transformed expression counts after scran normalisation. Colour indicates the experimental condition (left) and animal of origin (right) for each cell."}
# Global scaling normalisation + log tranformation + PCA
sce_naive_active <- computeSumFactors(sce_naive_active)
sce_naive_active <- logNormCounts(sce_naive_active)
sce_naive_active <- runPCA(sce_naive_active)
p_stimulus <- plotPCA(sce_naive_active, colour_by = "Stimulus") +
  theme(legend.position = "bottom")
p_batch <- plotPCA(sce_naive_active, colour_by = "Individuals") +
  theme(legend.position = "bottom")
multiplot(p_stimulus, p_batch, cols = 2)
```

In addition to cell-specific QC, we also recommend the use of a gene filtering 
step prior to the use of `r Biocpkg("BASiCS")`. 
The purpose of this filter is to remove lowly expressed genes that were largely
undetected through sequencing, making reliable variability estimates difficult
to obtain.
Here, we remove all genes that are not detected in at least 5 cells across both 
experimental conditions or that have an average read count below 1. 
These thresholds can vary across datasets and should be informed by 
gene-specific QC metrics such as those shown in
Figure \@ref(fig:gene-selection).

```{r gene-selection, fig.cap="Average read-count for each gene is plotted against the number of cells in which that gene was detected. Dashed grey lines are shown at the thresholds below which genes are removed."}
# Calculate per gene QC metrics
sce_naive_active <- addPerFeatureQC(sce_naive_active, exprs_values = "counts")
# Remove genes with zero total counts across all cells
sce_naive_active <- sce_naive_active[rowData(sce_naive_active)$detected != 0, ]
# Transform 'detected' metadata into number of cells 
rowData(sce_naive_active)$detected_cells <- 
  rowData(sce_naive_active)$detected * ncol(sce_naive_active) / 100
# Define inclusion criteria for genes
rowData(sce_naive_active)$include_gene <- rowData(sce_naive_active)$mean >= 1 &
  rowData(sce_naive_active)$detected_cells >= 5
plotRowData(
    sce_naive_active,
    x = "detected_cells",
    y = "mean",
    colour_by = "include_gene") +
  xlab("Total engogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  scale_x_log10() +
  scale_y_log10() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)) +
geom_vline(xintercept = 5, linetype = "dashed", col = "grey60") +
geom_hline(yintercept = 1, linetype = "dashed", col = "grey60")
# Apply gene filter
sce_naive_active <- sce_naive_active[rowData(sce_naive_active)$include_gene, ]
```

Subsequently, we also require users to remove spike-in molecules that were not 
captured through sequencing. We will do this separately for naive and active
cells separately.

```{r spike-ins-present}
ind_active <- sce_naive_active$Stimulus == "Active"
ind_naive <- sce_naive_active$Stimulus == "Unstimulated"
spikes <- assay(altExp(sce_naive_active))
detected_spikes_active <- rowSums(spikes[, ind_active] > 0) > 0
detected_spikes_naive <- rowSums(spikes[, ind_naive] > 0) > 0
detected_spikes <- detected_spikes_naive & detected_spikes_active
altExp(sce_naive_active) <- altExp(sce_naive_active)[detected_spikes, ]
```

The final dataset used in subsequent analyses contains 
`r ncol(sce_naive_active)` cells, `r nrow(sce_naive_active)` genes and 
`r nrow(altExp(sce_naive_active))` spike-ins.

## Input data for BASiCS

Here, we apply the `r Biocpkg("BASiCS")` model separately to cells from each
experimental condition (`r sum(sce_naive_active$Stimulus == "Unstimulated")` 
naive and `r sum(sce_naive_active$Stimulus == "Active")` activated cells). 
We create separate `SingleCellExperiment` objects for each group of cells. 

```{r SCE-separation}
sce_naive <- sce_naive_active[, ind_naive]
sce_active <- sce_naive_active[, ind_active]
```

`r Biocpkg("BASiCS")` requires the user to update these objects with additional
information, using a specific format.
Firstly, if multiple batches of sequenced cells are available (e.g. multiple 
donors that cells were extracted from, or multiple sequencing batches from the 
same experimental condition), this information must be included under the 
`BatchInfo` label as part of the cell-level metadata.

```{r BatchInfo}
colData(sce_naive)$BatchInfo <- colData(sce_naive)$Individuals
colData(sce_active)$BatchInfo <- colData(sce_active)$Individuals
```

If spike-ins will be used to aid data normalisation and technical noise 
quantification, `r Biocpkg("BASiCS")` also requires the number of spike-in 
molecules that were added to each well. 
For each spike-in gene $i$, this corresponds to:

$$ \mu_{i} = C_i \times 10^{-18} \times (6.022 \times 10^{23}) 
\times V \times D \hspace{0.5cm} \mbox{where,} $$

- $C_i$ is the concentration for the spike-in $i$ (measured in $aM\mu{}l^{-1}$),
- $V$ is the volume added into each well (measure in $nl$) and
- $D$ is a dilution factor. 

The remaining factors in the equation above are unit conversion constants
(e.g. from moles to molecules). 
For the CD4^+^ T cell data, the authors added a 1:50,000 dilution of the ERCC 
spike-in mix 1 and a volume of $9nl$ was added into each well (see [https://www.fluidigm.com/faq/ifc-9](https://www.fluidigm.com/faq/ifc-9)).
Finally, input concentrations $C_i$ can be downloaded from 
[https://assets.thermofisher.com/TFS-Assets/LSG/manuals](https://assets.thermofisher.com/TFS-Assets/LSG/manuals/cms_095046.txt).

```{r spike-in_download}
if (!file.exists("downloads/spike_info.txt")) {
  website <- "https://assets.thermofisher.com/TFS-Assets/LSG/manuals"
  file <- "cms_095046.txt"
  download.file(
    paste0(website, file),
    destfile = "downloads/spike_info.txt"
  )  
}

ERCC_conc <- read.table("downloads/spike_info.txt", sep = "\t", header = TRUE)
```

Based on this information, the calculation above proceeds as follows

```{r, ercc-mul}
# Moles per micro litre
ERCC_mmul <- ERCC_conc$concentration.in.Mix.1..attomoles.ul. * (10^(-18))
# Molecule count per micro litre (1 mole comprises 6.02214076 x 10^{23} molecules)
ERCC_countmul <- ERCC_mmul * (6.02214076 * (10^23))
# Application of the dilution factor (1:50,000)
ERCC_count <- ERCC_countmul / 50000
# Multiplying by the volume added into each well
ERCC_count_final <- ERCC_count * 0.009
```

To update the `sce_naive` and `sce_active` objects, the user must create a 
`data.frame` whose first column contains the labels associated to 
the spike-in molecule (e.g. ERCC-00130) and whose second column contains the 
input number of molecules calculated above.
We add this information as metadata for `altExp(sce_naive)` and 
`altExp(sce_active)`, respectively. 

```{r spike-info}
SpikeInput <- data.frame(
  Names = ERCC_conc$ERCC.ID,
  count = ERCC_count_final
)
# Exclude spike-ins not included in the input SingleCellExperiment objects
# and ensure the order of the rows is identical
SpikeInput <- SpikeInput[match(rownames(altExp(sce_naive)), SpikeInput$Names), ]

metadata(sce_naive)$SpikeInput <- SpikeInput
metadata(sce_active)$SpikeInput <- SpikeInput
```

## Parameter estimation using BASiCS

Parameter estimation is implemented in the `BASiCS_MCMC` function using an 
adaptive Metropolis within Gibbs algorithm [@Roberts2009].
The primary inputs for `BASiCS_MCMC` correspond to:

- `Data`: a `SingleCellExperiment` object created as described in the 
  previous sections. 
- `N`: the total number of MCMC iterations.
- `Thin`: thining period for output storage
  (only the `Thin`-th MCMC draw is stored).
- `Burn`: the initial number of MCMC iterations to be discarded.
- `Regression`: if `TRUE` a join prior is assigned to $\mu_i$ and $\delta_i$ 
  [@Eling2018], and residual over-dispersion values $\epsilon_i$ are inferred. 
  Alternatively, independent log-normal priors are assigned to $\mu_i$ and 
  $\delta_i$ [@Vallejos2016]. 
- `WithSpikes`: if `TRUE` information from spike-in molecules is used to aid
  data normalisation and to quantify technical noise. 

As a default, we recommend to use `Regression = TRUE` as we have observed that
the joint prior introduced by Eling *et al.* leads to improved inference for
small sample sizes and lowly expressed genes. 
Moreover, the joint prior formulation enables users to obtain a measure of
transcriptional variability that is not confounded by mean expression. 
Additional optional parameters can be used to store the generated output 
(`StoreChains`, `StoreDir`, `RunName`) and to monitor the progress of the 
algorithm (`PrintProgress`). 

Here, we run the MCMC sampler separately for naive and activated cells.
We use 40,000 iterations, discarding the initial 20,000 iterations.
We recommend this setting as a default choice, as we have observed it to 
ensure good convergence for the algorithm across multiple datasets.
However, for large datasets and less sparse datasets, a lower number of 
iterations may be sufficient. 
Practical guidance about the diagnostics criteria required to assess the 
performance of the MCMC algorithn is provided in the next section.

```{r MCMC-run, eval = FALSE}
chain_naive <- BASiCS_MCMC(
  Data = sce_naive,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "naive"
)

chain_active <- BASiCS_MCMC(
  Data = sce_active,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  WithSpikes = TRUE,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "active"
)
```

This first of these samplers takes 127 minutes to complete on a 3.4 GHz Intel 
Core i7 4770k procesor with 16GB RAM, while the second takes 75 minutes.
For convenience, these can be obtained online at 
[https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020](https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020).

```{r download-chain-naive}
if (!file.exists("rds/chain_naive.Rds")) {
  website <- "https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/raw/master/"
  file <- "chain_naive.Rds"
  download.file(
    paste0(website, file),
    destfile = "rds/chain_naive.Rds"
  )  
}
if (!file.exists("rds/chain_active.Rds")) {
  website <- "https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/raw/master/"
  file <- "chain_active.Rds"
  download.file(
    paste0(website, file),
    destfile = "rds/chain_active.Rds"
  )  
}
chain_naive <- readRDS("rds/chain_naive.Rds")
chain_active <- readRDS("rds/chain_active.Rds")
```

The output from `BASiCS_MCMC` is a `BASiCS_Chain` object that contains the 
draws associated to all model parameters (as `N` = 40,000, `Thin` = 20 and
`Burn` = 20,000, the object contains 1,000 draws for each parameter).
These can be accessed using the `displayChainBASiCS` function.
For example, the following code displays the first 2 draws for mean
expression parameters $\mu_i$ associated to the first 3 genes.

```{r displayChainBASiCS}
displayChainBASiCS(chain_naive, Param = "mu")[1:2, 1:3]
```

## MCMC diagnostics

Before interpreting the parameter estimates obtained by `r Biocpkg("BASiCS")`, 
it is critical to assess the convergence of the MCMC algorithm, i.e. whether
the MCMC reached its stationary distribution.
If convergence has been achieved, each parameter should not (on average) evolve
significantly over time, and draws are expected to be stochastic fluctuations 
around a horizontal trend.
Generally, it is not possible to prove convergence but multiple graphical and
quantitative convergence diagnostics have been proposed to assess the lack
of convergence (e.g. [@CowlesCarlin1996; @BrooksGelman1998]). 
Some advocate the use of multiple MCMC chains using different starting values in
order to ensure that the algorithm consistently converges to the same 
distribution.
For `r Biocpkg("BASiCS")`, we have observed that using informed starting values 
(e.g. based on `r Biocpkg("scran")` normalisation) and a sufficiently large 
value for `N` and `Burn` generally leads to consistent across multiple MCMC runs.
Hence, the focus of this section is to evaluate quantitative measures of 
convergence (e.g. [@Geweke1995]) based on a single MCMC chain.

Traceplots can be used to visually assess the history of posterior draws 
generated by the algorithm for a specific parameter (e.g. Figure
\@ref(fig:convergence-naive)). 
As mentioned above, significan departures from a horizontal trend suggest a
lack of convergence.
As illustrated in Figure \@ref(fig:convergence-naive), histograms can also be 
used to display the marginal distribution for each parameter. 
Users should expect these to follow a unimodal distribution. 
Failure to satisfy these graphical diagnostics suggest that `N` and `Burn` must 
be increased. 
Alternatively, more stringent quality control could be applied to the input 
data, as genes with very low counts often suffer from slow convergence and poor sampling efficiency.

```{r convergence-naive, fig.cap="Trace plot, marginal histogram, and autocorrelation function for a gene in naive cells following MCMC sampling. Trace plots should explore the posterior well, without getting stuck in one location or drifting over time towards a region of higher density. High autocorrelation indicates that the number of effective independent samples is low. It is good practice to perform these visualisation for many different parameters; here we only show one."}
plot(chain_naive, Param = "mu", Gene = 1)
```

As `r Biocpkg("BASiCS")` infers thousands of parameters, it is 
impractical to assess these graphical diagnostics for each parameter. 
Thus, it is helpful to use numerical diagnostics that can be applied to multiple
parameters simultaneously to judge whether the algorithm has failed to converge.
Here, we focus on the diagnostic criterion proposed by Geweke [@Geweke1995]
which compares the average draws obtained during the initial (10\% after burn 
in, by default) and the final part of the chain (50\% by default).
Large absolute Z-scores suggest that the algorithm has not converged. 
For the naive and activatived CD4^+^ T datasets most Z-scores associated to mean
expression parameters $\mu_i$ were small in aboslute value (see Figure \@ref(fig:geweke-diag)).

<!--- CAV: I removed the next sentence, trend is not that clear
after applying the additional gene filter. 

Further, as seen in Figures \@ref(fig:geweke-diag-mean) and
\@ref(fig:geweke-diag-detected), genes with large absolute values for this 
criterion are often those genes that have a low average expression level, or 
that are expressed only in a small proportion of cells.
---> 

```{r geweke-diag, fig.cap="Geweke Z-score for mean expression parameters is plotted against mean expression estimates for naive (left) and activated (right) cells."}
library("coda")
library("ggplot2")
library("viridis")

# Calculate and plot Geweke Z scores 
gew_mu_naive <- geweke.diag(mcmc(displayChainBASiCS(chain_naive, Param = "mu")))$z
gew_mu_active <- geweke.diag(mcmc(displayChainBASiCS(chain_active, Param = "mu")))$z

myplot_params <- list(
  geom_hex(),
  geom_hline(yintercept = c(-3, 3), col = "firebrick", linetype = "dashed"),
  scale_fill_viridis(),
  labs(x = "log(mu)", y = "Geweke Z-score"))

p_geweke_naive <- ggplot() +
  aes(
    log10(colMedians(displayChainBASiCS(chain_naive, Param = "mu"))),
    gew_mu_naive
  ) +
  myplot_params +
  ggtitle("Naive cells")
p_geweke_active <- ggplot() +
  aes(
    log10(colMedians(displayChainBASiCS(chain_active, Param = "mu"))),
    gew_mu_active
  ) +
  myplot_params+
  ggtitle("Activated cells")

multiplot(p_geweke_naive, p_geweke_active, cols = 2)
```

As well as assessing the convergence of the MCMC algorithm, it is important
to ensure that the MCMC algorithm has efficiently explored the parameter space. 
For example, the autocorrelation function (e.g. Figure 
\@ref(fig:convergence-naive), right panel) can be used to quantify the 
correlation between the chain and its lagged versions. 
Strong autocorrelation indicates that neighbouring MCMC samples are highly 
dependent and suggest poor sampling efficiency. 
Low sampling efficiency may indicate that the MCMC draws do not contain 
sufficient information to produce accurate posterior estimates.
In other words, highly correlated MCMC samplers require more samples to produce
the same level of Monte Carlo error for an estimate 
(defined as the variance of a Monte Carlo estimate across repetitions [@Koehler2009]). 

The effective sample size (ESS) is a related measure which represents a proxy 
for the number of independent draws generated by the MCMC sampler [@Gelman2014].
The latter is defined as:
$$
  \mbox{ESS} = \frac{N_{tot}}{1 + 2\sum_{k=1}^\infty \rho(k)},
$$
where $N_{tot}$ represents the total number of MCMC draws (after burn-in and
thining) and $\rho(k)$ $\rho(k)$ is the autocorrelation at lag $k$.
ESS estimates associated to mean expression parameters for the naive and 
activated CD4^+^ T cells are displayed in Figure \@ref(fig:ess-diag).
Whilst ESS is around 1,000 for most genes, we observe low ESS values for a
small proportion of genes (primarily lowly expressed genes whose expression
was only captured in a small number of cells).
As described later in this manuscript, `BASiCS_TestDE` automatically excludes 
genes with low ESS when performing differential expression testing.

```{r ess-diag, fig.cap="ESS for mean expression parameters is plotted against mean expression estimates for naive (left) and activated (right) cells."}
ess_mu_naive <- BASiCS_DiagPlot(chain_naive, Param = "mu") 
ess_mu_active <- BASiCS_DiagPlot(chain_active, Param = "mu")
multiplot(ess_mu_naive, ess_mu_active, cols = 2)
```

<!--- CAV: sentence removed as trend is not clear after additional gene filter

Furthermore, Figure \@ref(fig:geweke-diag-ess) demonstrates 
that the Geweke diagnostic criterion is closely related to effective sample 
size, such that parameters with large Z-scores often have very low effective 
sample sizes.
--->

<!---
## Global scaling normalisation using BASiCS

Global scaling normalisation techniques for scRNA-seq data can be used to infer
cell-specific scaling factors that capture systematic differences in the scale
of the expression counts across cells. 
Generally, these scaling factors capture both biological (e.g. mRNA content) and technical (e.g. sequencing depth) factors, but spike-in genes can be used to
disentangle these effects [@Vallejos2017]. 
For example, when spike-in genes are used to assist data normalisation, 
`r Biocpkg("BASiCS")` infers two separate sets of cell-specific parameters 
associated to these sources of variability: $\phi_j$ and $\nu_j$, respectively.  
Posterior estimates for these parameters ($\hat{\phi}_j$, $\hat{\nu}_j$) can be 
used to normalise the input data via the `BASiCS_DenoisedCounts` function. 
The latter returns normalised expression values defined as
$$
  x^*_{ij} = \frac{ x_{ij} } {\hat{\phi}_j \hat{\nu}_j},
$$
where $x_{ij}$ denotes the observed expression count for gene $i$ in cell $j$.

```{r normalisation-naive}
norm_basics_naive <- BASiCS_DenoisedCounts(Data = sce_naive, Chain = chain_naive)
norm_basics_active <- BASiCS_DenoisedCounts(Data = sce_active, Chain = chain_active)
```

```{r normalisation-vs-scran, fig.cap="Comparison of BASiCS inferred global scaling factors and those estimated by scran using the method of Lun et al. (2016)."}
# BASiCS scaling factors within each group of samples
basics_sf_naive <- colMedians(
  displayChainBASiCS(chain_naive, "phi")
  * displayChainBASiCS(chain_naive, "nu")
)
basics_sf_active <- colMedians(
  displayChainBASiCS(chain_active, "phi")
  * displayChainBASiCS(chain_active, "nu")
)
# scran scaling factors within each group of samples
scran_sf_naive <- calculateSumFactors(sce_naive)
scran_sf_active <- calculateSumFactors(sce_active)

g1 <- ggplot() +
  aes(basics_sf_naive, scran_sf_naive) +
  geom_point() +
  ggtitle("Naive cells") +
  labs(x = "BASiCS scaling factors", y = "scran scaling factors") +
  annotate(x=14, y=0.4, 
         label=paste("Pearson's r = ", 
                     round(cor(basics_sf_naive, scran_sf_naive),2)), 
         geom="text", size=4)
g2 <- ggplot() +
  aes(basics_sf_active, scran_sf_active) +
  geom_point() +
  ggtitle("Activated cells") +
  labs(x = "BASiCS scaling factors", y = "scran scaling factors") +
  annotate(x=12, y=0.6, 
         label=paste("Pearson's r = ", 
                     round(cor(basics_sf_active, scran_sf_active),2)), 
         geom="text", size=4)
multiplot(g1, g2, cols = 2)
```


As shown in Figure \@ref(fig:normalisation-vs-scran), the capture efficiency and 
scaling factors ($\nu_j$ and $\phi_j$ respectively) inferred by 
`r Biocpkg("BASiCS")` are highly correlated with the global scaling 
normalisation factors inferred using the method of @Lun2016.
An advantage of jointly inferring normalisation and gene-specific expression
parameters, rather than using pre-computed
normalisation factors, is that in the former case, statistical uncertainty is 
propagated from normalisation to all downstream analyses.

--->

## Quantifying transcriptional variability using BASiCS

`r Biocpkg("BASiCS")` uses gene-specific over-dispersion parameters $\delta_i$ 
as a proxy for transcriptional variability within a population of cells. 
Figure \@ref(fig:dispersion-vs-mean) displays posterior estimates for 
over-dispersion parameters inferred for the naive and activated CD4^+^ T cells 
and how these relate to mean expression estimates.  
Following [@Eling2018], we also derive posterior estimates for residual
over-dispersion parameters $\epsilon_i$, a measure of variability that is not
confounded by mean expression (see Figure \@ref(fig:residual-vs-mean)). 
As seen in Figure \@ref(fig:residual-vs-mean) [TEXT IS WIP]

Similarly, Kolodziejczyk _et al._ used the distance to a rolling median (DM) 
along the mean-variability trend to correct for this confounding factor 
[@Kolodziejczyk2015cell].
Here, we highlight how to obtain the residual variability estimates using 
`r Biocpkg("BASiCS")` and `r Biocpkg("scran")`.

Widely used measures of expression variability include the variance 
[@Shalek2014], the Fano factor (variance divided by mean expression) 
[@Wills2013;@Grun2014;@Arriaga2009] and 
the coefficient of variation (CV, variance divided by squared mean expression) 
[@Buettner2015;@Brennecke2013].
Here, we highlight the mean-variance relationship for each variability 
measures. For this analysis, we exclude genes that are not expressed in at 
least 2 cells.
These genes have missing (`NA`) values for the residual over-dispersion 
parameter, $\epsilon$. These values can be obtained using the function
`displayChainBASiCS`.
We will use `r CRANpkg("ggpointdensity")` to visualise the local density of
genes along the axes of mean and variability.

Figures \@ref(fig:variability-measures), \@ref(fig:fano-fig),
and \@ref(fig:cv-fig) demonstrate that these measures each correlate strongly
with mean expression. Again, for this comparison,
we exclude genes that are not observed to be expressed in at least 2 cells,
given that variability cannot meaningfully be quantified given a single 
observation.

The over-dispersion parameters estimated using `r Biocpkg("BASiCS")`
show strong correlation with CV^2^, as seen in Figure \@ref(fig:cv-basics).
Furthermore, Figure \@ref(fig:CV-comparison-BASiCS) shows that the 
over-dispersion parameters estimated by `r Biocpkg("BASiCS")` are strongly
correlated with mean expression. 
Recently, we extended `r Biocpkg("BASiCS")` to explicitly model this 
mean-variability relationship by performing an internal regression between the 
over-dispersion and mean expression parameters, as visualised in Figure 
\@ref(fig:naive-fit). This results in the $\epsilon$ parameter, a measure
of variability above or below that expected based on the overall mean-variance
relationship.
Similarly, Kolodziejczyk _et al._ used the distance to a rolling median (DM) 
along the mean-variability trend to correct for this confounding factor 
[@Kolodziejczyk2015cell].
Here, we highlight how to obtain the residual variability estimates using 
`r Biocpkg("BASiCS")` and `r Biocpkg("scran")`.

Neither the DM nor the residual over-dispersion estimates show association 
with mean expression, as shown in Figures \@ref(fig:mean-dispersion-basics) 
and \@ref(fig:mean-dispersion-dm).
Furthermore, these mean-independent variability measures are highly correlated,
as seen in Figure \@ref(fig:epsilon-dm).
These measures can be used to associate genomic features 
[@Morgan2018;@Faure2017] or transcriptional dynamics [@Antolovic2017] to 
gene expression variability.
While the DM is calculated as a point estimate, `r Biocpkg("BASiCS")` stores 
each posterior sample within the `BASiCS_Chain` object.
They can be accessed using the `displayChain` function. This function
extracts cell- or gene-specific samples in the form of a matrix, wherein each 
column contains cell- or gene-specific parameters, and rows contain the MCMC 
samples.

```{r individual-samples}
displayChainBASiCS(chain_naive, Param = "epsilon")[1:10, 1:10]
```

<!-- **TODO: Not sure if we need this** why not? doesn't hurt imo -->
By testing a certain association for each MCMC sample, for example between 
CpG island length and variability [@Morgan2018], one can generate a
posterior distribution of the test statistic. 

```{r dispersion-vs-mean, fig.cap="Over-dispersion estimates obtained by BASiCS are plotted against mean expression for all genes on a log-log scale. Colour represents local density, with lighter colours representing higher density."}

library("ggpointdensity")
library("viridis")

# Obtain point estimates within each group of cells
summary_naive <- Summary(chain_naive)
summary_active <- Summary(chain_active)
DF <- data.frame(
  "mu_naive" = displaySummaryBASiCS(summary_naive, Param = "mu")[,1],
  "mu_active" = displaySummaryBASiCS(summary_active, Param = "mu")[,1],
  "delta_naive" = displaySummaryBASiCS(summary_naive, Param = "delta")[,1],
  "delta_active" = displaySummaryBASiCS(summary_active, Param = "delta")[,1],
  "eps_naive" = displaySummaryBASiCS(summary_naive, Param = "epsilon")[,1],
  "eps_active" = displaySummaryBASiCS(summary_active, Param = "epsilon")[,1]
  )

# Over-dispersion versus mean expression
p_delta_naive <- ggplot(DF) +
  geom_pointdensity(aes(log(mu_naive), log(delta_naive))) +
  scale_colour_viridis() +
  labs(x = "Mean expression estimates",
       y = "Over-dispersion estimates") +
  ggtitle("Naive cells")
p_delta_active <- ggplot(DF) +
  geom_pointdensity(aes(log(mu_active), log(delta_active))) +
  scale_colour_viridis() + 
  labs(x = "Mean expression estimates",
       y = "Over-dispersion estimates") +
  ggtitle("Activated cells")
multiplot(p_delta_naive, p_delta_active, cols = 2)
```


```{r residual-vs-mean, fig.cap="Residual over-dispersion estimates obtained by BASiCS are plotted against mean expression (log-scale). Colour represents local density, with lighter colours representing higher density. Genes that are not observed to be expressed in at least 2 cells within each group are excluded."}

p_eps_naive <- ggplot(DF[!is.na(DF$eps_naive),]) +
  geom_pointdensity(aes(log(mu_naive), eps_naive)) +
  scale_colour_viridis() +
  labs(x = "Mean expression estimates",
       y = "Residual over-dispersion estimates") +
  ggtitle("Naive cells")
p_eps_active <- ggplot(DF[!is.na(DF$eps_active),]) +
  geom_pointdensity(aes(log(mu_active), eps_active)) +
  scale_colour_viridis() + 
  labs(x = "Mean expression estimates",
       y = "Residual over-dispersion estimates") +
  ggtitle("Activated cells")
multiplot(p_eps_naive, p_eps_active, cols = 2)
```

```{r compare-variability, fig.cap="Residual over-dispersion estimates obtained by BASiCS are plotted against mean expression (log-scale). Colour represents local density, with lighter colours representing higher density. Genes that are not observed to be expressed in at least 2 cells within each group are excluded."}

p_eps_naive <- ggplot(DF[!is.na(DF$eps_naive),]) +
  geom_pointdensity(aes(log(mu_naive), eps_naive)) +
  scale_colour_viridis() +
  labs(x = "Mean expression estimates",
       y = "Residual over-dispersion estimates") +
  ggtitle("Naive cells")
p_eps_active <- ggplot(DF[!is.na(DF$eps_active),]) +
  geom_pointdensity(aes(log(mu_active), eps_active)) +
  scale_colour_viridis() + 
  labs(x = "Mean expression estimates",
       y = "Residual over-dispersion estimates") +
  ggtitle("Activated cells")
multiplot(p_eps_naive, p_eps_active, cols = 2)
```

```{r}
sce_naive <- logNormCounts(sce_naive, log = FALSE)
sce_active <- logNormCounts(sce_active, log = FALSE)
DF$mean_scran_naive <- rowMeans(assay(sce_naive, "normcounts"))
DF$mean_scran_active <- rowMeans(assay(sce_active, "normcounts"))
DF$var_scran_naive <- rowVars(assay(sce_naive, "normcounts"))
DF$var_scran_active <- rowVars(assay(sce_active, "normcounts"))
DF$cv2_scran_naive <- DF$var_scran_naive / DF$mean_scran_naive^2
DF$cv2_scran_active <- DF$var_scran_active / DF$mean_scran_active^2
DF$DM_naive <- DM(mean = DF$mean_scran_naive, cv2 = DF$cv2_scran_naive)
DF$DM_active <- DM(mean = DF$mean_scran_active, cv2 = DF$cv2_scran_active)

p_delta_cv2_naive <- ggplot(DF[!is.na(DF$eps_naive),]) +
  geom_pointdensity(aes(log(delta_naive), log(cv2_scran_naive))) +
  scale_colour_viridis() +
  labs(x = "Over-dispersion estimates",
       y = "CV^2") +
  ggtitle("Naive cells")
p_delta_cv2_active <- ggplot(DF[!is.na(DF$eps_active),]) +
  geom_pointdensity(aes(log(delta_active), log(cv2_scran_active))) +
  scale_colour_viridis() +
  labs(x = "Over-dispersion estimates",
       y = "CV^2") +
  ggtitle("Activated cells")

p_eps_DM_naive <- ggplot(DF[!is.na(DF$eps_naive),]) +
  geom_pointdensity(aes(eps_naive, DM_naive)) +
  scale_colour_viridis() +
  labs(x = "Residual over-dispersion estimates",
       y = "DM estimates") +
  ggtitle("Naive cells")
p_eps_DM_active <- ggplot(DF[!is.na(DF$eps_active),]) +
  geom_pointdensity(aes(eps_active, DM_active)) +
  scale_colour_viridis() +
  labs(x = "Residual over-dispersion estimates",
       y = "DM estimates") +
  ggtitle("Activated cells")

multiplot(p_delta_cv2_naive, p_delta_cv2_active,
          p_eps_DM_naive, p_eps_DM_active,
          cols = 2)
```

## HVG/LVG detection using BASiCS

<!--- CAV: some of the text below is redundant --->

Numerous studies have highlighted the relationship between gene-specific 
variability measures (e.g., squared coefficient of variation) and mean 
abundance [@Ritchie2015;@Grun2014;@Love2014;@McCarthy2012].
`r Biocpkg("BASiCS")` provides the `BASiCS_ShowFit` function that plots the
gene-specific 
over-dispersion parameters (delta) versus mean expression parameters (mu). 

```{r naive-fit, fig.cap="Over-dispersion is plotted against mean expression for naive cells on a log-log scale. Colour corresponds to local density, with lighter colours representing higher density; a curve represents the inferred trend of over-dispersion against mean, while the shaded area represents the corresponding 95\\% high density interval."}
BASiCS_ShowFit(chain_naive)
```

Here, we observe that the over-dispersion estimates are inversely correlated
with mean expression.
However, by performing a regression between over-dispersion and mean 
expression, we can correct for this trend and obtain variability measures that 
show no correlation with mean expression [@Eling2018]. This is performed jointly
while estimating mean and over-dispersion for each gene, and incorporating
this information can help to stabilise inference, in particular for genes
with very low average counts. The purple points in the plot indicate genes that 
are not expressed in at least 2 cells.
`r Biocpkg("BASiCS")` automatically excludes these genes when assessing gene 
variability,
given that it is not possible to quantify variability or changes in variability
for genes that are only expressed in one cell.

`r Biocpkg("BASiCS")` offers the functions `BASiCS_DetectHVG` and 
`BASiCS_DetectLVG` to select genes with large or small 
biological variance. If the MCMC sampler was run with `Regression = TRUE`,
these functions take the `BASiCS_Chain` object and a quantile threshold.
Using the residual over-disperison parameters, genes are ranked by their 
variability and the `BASiCS_DetectHVG` function selects (for example) the 
10% most highly variable genes (`PercentileThreshold = 0.9`).
Similarly, when detecting lowly variable genes, the `BASiCS_DetectLVG` selects 
the 10% most lowly variable genes (`PercentileThreshold = 0.1`).
The probability threshold for a gene showing higher variability than the 
percentile threshold is found by controlling the expected false discovery 
rate (EFDR) to 10% (by default) [@Newton2004].
<!-- todo: explain EFDR -->

```{r naive-HVG-LVG}
# Highly variable genes
HVG <- BASiCS_DetectHVG(chain_naive, PercentileThreshold = 0.9)

# Lowly variable genes
LVG <- BASiCS_DetectLVG(chain_naive, PercentileThreshold = 0.1)
HVG_table <- HVG@Table
LVG_table <- LVG@Table
```

This analysis results in the detection of *`r sum(HVG_table$HVG, na.rm=TRUE)`*
highly variable genes and *`r sum(LVG_table$LVG, na.rm=TRUE)`*
lowly variable genes.

The `Biocpkg("scran")` provides similar functions to detect HVGs and we can 
compare the results of both methods.
`r Biocpkg("scran")` first fits a smooth regression between the squared
coefficient of variation (CV^2^) of the gene-wise expression counts and their 
mean abundance using the `modelGeneCV2` function.
Furthermore, it computes a ratio of the observed CV^2^ to the value predicted by
the trend fitted to the CV^2^ and mean values across all genes. Genes with 
larger ratios are assumed to demonstrate biologically variability, while genes
with smaller ratios are assumed to be driven largely by technical noise.

```{r HVG-LVG-scran}
# Variance decomposition
var_out <- modelGeneCV2(sce_naive)
var_out <- var_out[HVG_table$GeneName, ]
```

Here, we define HVGs as those genes with a CV^2^ more than double that
predicted based on mean expression using the fitted trend,
while controlling the FDR to 5%.
As described by `r Biocpkg("SimpleSingleCell")` and by 
[*OSCA*](https://osca.bioconductor.org/), different methods
can be used to identify depending on the intended downstream analysis,
and thresholds should be adjusted based on the characteristics
[@Lun2016;@Amezquita2019]
We can then compare the the overlap of the HVG identified by 
`r Biocpkg("scran")` and by `r Biocpkg("BASiCS")` (shown in Figure
\@ref(fig:scran-HVG)).

```{r scran-HVG, fig.cap="Epsilon (residual over-dispersion) is plotted against log(mu) (log mean expression). Colour indicates the results of scran and BASiCS HVG tests."}
is_hvg <- var_out$ratio > 2 & var_out$FDR < 0.05
ind_hvg <- which(is_hvg)
hvg_out <- var_out[ind_hvg, ]
hvg_out <- hvg_out[order(hvg_out$FDR), ]
nrow(hvg_out)

# Compare BASiCS and scran results
plot_data <- data.frame(
  Mu = HVG_table$Mu,
  Epsilon = HVG_table$Epsilon,
  BASiCS_HVG = HVG_table$HVG,
  scran_HVG = is_hvg
)
plot_data <- plot_data[complete.cases(plot_data), ]
plot_data <- cbind(plot_data, 
  BASiCS = ifelse(plot_data$BASiCS_HVG, "HVG", "Not HVG"),
  scran = ifelse(plot_data$scran_HVG, "HVG", "Not HVG")
)


ord <- order(plot_data$scran, plot_data$BASiCS, decreasing = TRUE)
plot_data <- plot_data[ord, ]
plot_data$Status <- paste0(
  "BASiCS: ", plot_data$BASiCS, "\n",
  "scran: ", plot_data$scran, "\n")
ggplot(plot_data) +
  geom_point(
    aes(log(Mu), Epsilon, colour = Status),
    alpha = 0.5,
    shape = 16
  ) +
  scale_colour_brewer(palette = "Paired")
```

*`r length(intersect(rownames(hvg_out), HVG_table$GeneName[HVG_table$HVG]))`*
of the *`r nrow(hvg_out)`* HVGs of scran are among the
*`r sum(HVG_table$HVG)`* HVGs identified by `r Biocpkg("BASiCS")`.

<!-- 
We can now compare these gene-specific variability measures (over-dispersion and 
residual over-dispersion) to previously used measures to quantify cell-to-cell 
expression variability [@Brennecke2013,@Kolodziejczyk2015cell].
-->

## Differential mean expression testing using BASiCS

This section highlights the use of `r Biocpkg("BASiCS")` to perform 
differential expression
tests for mean and variability between cells of two conditions. 
For convenience, we will compare the naive CD4^+^ T cells, analysed 
in the previous section, to activated CD4^+^ T cells of the same dataset 
[@Martinez-jimenez2017]. Naive CD4^+^ T cells were activated for 3 hours 
using plate-bound CD3e and CD28 antibodies.
T cell activation is linked to strong transcriptional shifts and the
up-regulation of lineage specific marker genes, such as Tbx21 and Gata1 
[@Best2013;@Fu2012].
To generate this data, the authors did not add cytokines, which are needed for 
T cell differentiation [@Zhu2010]. Therefore, any heterogeneity in the activated
cell population does not arise from cells residing in different lineage-specific 
differentiation states. Prior to differential testing, and as explained above, 
we need to generate a `SingleCellExperiment` object that is compatible for
processing using `r Biocpkg("BASiCS")`.

To perform robust differential mean expression testing, `r Biocpkg("BASiCS")`
removes genes with small effective sample size when calculating EFDR and 
performing differential expression testing.
As explained [above](#naive-convergence), `r Biocpkg("BASiCS")` automatically 
excludes genes with an effective sample size less than 100.

The default settings for differential mean expression testing are as follows:

- `EpsilonM`: Log~2~ fold change (LFC) threshold for changes in mean expression.
  Default value is $\log_2(1.5)\approx0.41$.
  differential tests. Default value is 100.
- `EFDR_M`: Expected false discovery rate: 10%
- `MinESS`: Minimum effective sample size for genes to be included in 
- `Plot`, `PlotOffset`: Boolean to control if results are plotted.
  Default value is TRUE for both.

```{r mean-expression-testing}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = chain_naive,
  Chain2 = chain_active,
  EpsilonM = log2(1.5),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  MinESS = 100
)
```

After running the test, we can now visualise the results in form of a MA-plot 
(log ratio _versus_ mean average; Figure \@ref(fig:visualise-MA-plot))
and volcano plot (posterior probability _versus_ log ratio; Figure
\@ref(fig:visualise-volcano-plot)).

```{r visualise-MA-plot, fig.cap="Fold changes of average expression in naive cells relative to active cells are plotted again mean expression. Colour indicates genes that were excluded from differential expression test, and those with significantly higher mean expression in either group."}
BASiCS_PlotDE(Test_DE, Parameters = "Mean", Plots = "MA")
```


```{r visualise-volcano-plot, fig.cap="Posterior probability of differential expression is plotted again log fold change. Colour indicates genes that were excluded from differential expression test, and those with significantly higher mean expression in either group."}
BASiCS_PlotDE(Test_DE, Parameters = "Mean", Plots = "Volcano")

TableMean <- format(Test_DE, Which = "Mean", Filter = FALSE)
```

As we can see for the comparison of naive and activated CD4^+^ T cells, most 
genes show strong differences in mean expression.
In such cases, it can be beneficial to increase the LFC threshold or to 
decrease the target EFDR.
Here, we set the LFC threshold to $\log_2(2)=1$ to detect genes 
with strong changes in mean expression. We also set `MinESS` to 100,
causing genes with effective sample size less than 100 in either input chain
to be excluded from EFDR calibration and differential expression testing.


```{r mean-expression-testing-2}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = chain_naive,
  Chain2 = chain_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  MinESS = 100
)
TableMean <- format(Test_DE, Which = "Mean", Filter = FALSE)
TableDisp <- format(Test_DE, Which = "Disp", Filter = FALSE)
table(TableMean$ResultDiffMean)
```

<!---
In this case, this results in 
r  `sum(TableMean$ResultDiffMean=="ExcludedLowESS")` genes with low 
effective sample size being excluded from differential mean expression tests.
Similarly, r `sum(TableDisp$ResultDiffDisp=="ExcludedLowESS")`
genes are excluded from tests of differential over-dispersion due to
low effective sample size.
--->

When interpreting the results of differential expression tests, it is useful
to visualise the differentially expressed genes in order to appraise the 
significance of the results. It is also useful to
perform functional enrichment analysis to identify biologically 
meaningful patterns, for example using `r Biocpkg("goseq")` [@Young2010].
We do not perform this here, as it is outside of the scope of 
`r Biocpkg("BASiCS")`. However, a workflow for this process 
is detailed in Supplementary section TODO.

The molecule counts used in this workflow are annotated using Ensembl gene
identifiers. In order to facilitate the visualisation and interpretation
of results, it is often useful
to generate a mapping from Ensembl gene IDs to 
gene symbols using the BioMart software suite 
([http://www.biomart.org](http://www.biomart.org)) using 
the Bioconductor package, `r Biocpkg("biomaRt")` [@Durinck2009].
These packages can also be used to obtain gene-pathways mappings and
information such as gene length, useful for performing functional analysis
of the gene sets identified.

```{r obtain-gene-symbols}
dir.create("rds", showWarnings = FALSE)
dir.create("downloads", showWarnings = FALSE)

if (!file.exists("rds/genenames.rds")) {
  # Initialize mart and dataset
  ensembl <- useMart(
    biomart = "ensembl",
    dataset = "mmusculus_gene_ensembl"
  )

  # Select gene ID and gene name
  genenames <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    mart = ensembl
  )

  rownames(genenames) <- genenames$ensembl_gene_id
  saveRDS(genenames, "rds/genenames.rds")
} else {
  genenames <- readRDS("rds/genenames.rds")
}
```

It is useful to visualise differentially expressed genes to ensure that
the identified genes are the result of biologically meaningful shifts in 
expression and not technical issues. As an example, we visualise the
expression of Cd69, a known marker of T cell activation [@Ziegler1994],
in Figures \@ref(fig:violin-plots) and \@ref(fig:pca-cd69).

```{r violin-plots, fig.cap="Violin plot of Cd69 expression in naive and active cells."}
# Expression of Cd69 in both conditions
ind_cd <- genenames$external_gene_name == "Cd69"
plotExpression(sce_naive_active,
  features = genenames[ind_cd, 1],
  x = "Stimulus"
)
```

```{r pca-cd69, fig.cap="Principal component plot of naive and stimulated T cells. Colour indicates Cd69 expression level."}
plotReducedDim(sce_naive_active,
  dimred = "PCA",
  colour_by = genenames[ind_cd, 1]
) + scale_fill_viridis(name = "Cd69")
```


It may also useful to visualise many genes at once. This is useful in quality
checking the results of a differential expression analysis, and may also
aid in identifying systematic patterns among differentially expressed genes
and guiding downstream analysis. Here we use `r Biocpkg("ComplexHeatmap")`
to visualise genes that are up-regulated in each condition [@Gu2016],
the output of which is shown in Figure \@ref(fig:heatmap-diffexp).

```{r heatmap-diffexp, fig.width = 7, fig.height = 5, fig.cap="Heatmap of 30 differentially expressed genes in naive or active cells. Colour indicates expression level; colour bars on the right of heatmap segments indicate the logged average expression for each gene in each population."}
library("ComplexHeatmap")
library("circlize")
library("RColorBrewer")

# Up-regulated in naive
ind_n <- TableMean$ResultDiffMean == "Naive+"
naive_mean <- TableMean[ind_n, ]
naive_mean <- naive_mean[order(naive_mean$MeanLog2FC, decreasing = FALSE), ]
naive_mean$Symbol <- genenames[naive_mean$GeneName, 2]

# Up-regulated in active
ind_a <- TableMean$ResultDiffMean == "Active+"
active_mean <- TableMean[ind_a, ]
active_mean <- active_mean[order(active_mean$MeanLog2FC, decreasing = TRUE), ]
active_mean$Symbol <- genenames[active_mean$GeneName, 2]

heatmap_ngenes <- 15
heatmap_seq <- seq_len(heatmap_ngenes)

## Select genes with largest probability of differential expression
active_ind <- order(active_mean$ProbDiffMean, decreasing = TRUE)[heatmap_seq]
active_mean <- active_mean[active_ind, ]
## subset counts from each cell type to these genes
act_counts_act <- counts(sce_active)[active_mean$GeneName, ]
nai_counts_act <- counts(sce_naive)[active_mean$GeneName, ]

## Select genes with largest probability of differential expression
s_ind <- order(naive_mean$ProbDiffMean, decreasing = TRUE)[heatmap_seq]
naive_mean <- naive_mean[s_ind, ]
## subset counts from each cell type to these genes
act_counts_nai <- counts(sce_active)[naive_mean$GeneName, ]
nai_counts_nai <- counts(sce_naive)[naive_mean$GeneName, ]

## Calculate max absolute value for min/max of colour scale
all_mean <- c(
  active_mean$Mean1, active_mean$Mean2,
  naive_mean$Mean1, naive_mean$Mean2
)
max_range <- log(max(abs(all_mean)))
## colour scale symmetric around zero
colour <- colorRamp2(seq(-max_range, max_range, length.out = 9),
  rev(brewer.pal(9, "RdBu")))

## Combine count matrices by cell type
counts_active <- rbind(act_counts_act, act_counts_nai)
counts_naive <- rbind(nai_counts_act, nai_counts_nai)

## split heatmaps by gene category
split <- data.frame(
  Upregulated = c(
    rep("Up-regulated \nin active", nrow(act_counts_act)),
    rep("Up-regulated \nin naive", nrow(act_counts_nai))
  )
)
syms <- genenames[rownames(counts_active), 2]
fontsize <- 7

Heatmap(
  log10(counts_naive + 1),
  row_labels = syms,
  row_names_gp = gpar(fontsize = fontsize),
  name = "log10(count + 1)",
  column_dend_height = unit(0.2, "npc"),
  column_title_side = "bottom",
  column_title = "Naive cells",
  show_column_names = FALSE,
  cluster_rows = FALSE,
  split = split,
  right_annotation = rowAnnotation(
    log_mu = log(c(active_mean$Mean1, naive_mean$Mean1)),
    col = list(log_mu = colour)
  ),
  col = viridis(100)) +
Heatmap(
  log10(counts_active + 1),
  row_labels = syms,
  column_dend_height = unit(0.2, "npc"),
  row_names_gp = gpar(fontsize = fontsize),
  column_title = "Active cells",
  column_title_side = "bottom",
  show_column_names = FALSE,
  name = "log10(count + 1)",
  split = split,
  right_annotation = rowAnnotation(
    log_mu = log(c(active_mean$Mean2, naive_mean$Mean2)),
    col = list(log_mu = colour)
  ),
  cluster_rows = FALSE,
  col = viridis(100))
```

While other computational tools exist to perform differential mean expression
analysis, we next want to highlight the use of `r Biocpkg("BASiCS")` for 
differential variability testing.

## Differential variability expression testing using BASiCS

Due to the negative association between over-dispersion and mean expression 
parameters, only genes that do not show a change in mean expression.
To avoid the confounding effect of mean expression, we perform differential 
expression testing by setting the LFC threshold on mean expression to 
`EpsilonM = 0`, while using the default LFC threshold on changes in 
over-dispersion: `EpsilonD = log2(1.5)`.
Furthermore, it is crucial to exclude lowly expressed genes from this 
analysis to avoid biases arising from non-informative genes showing only
low levels of stochastic expression.

```{r over-dispersion-testing}
# Select genes that show expression in both conditions
high_expr <- TableMean$Mean1 > 1 & TableMean$Mean2 > 1

Test_DE_LFC0 <- BASiCS_TestDE(
  Chain1 = chain_naive,
  Chain2 = chain_active,
  EpsilonM = 0,
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  Plot = FALSE,
  PlotOffset = FALSE,
  MinESS = 100,
  GenesSelect = high_expr
)
```

We first select the genes that remain similarly expressed between both 
conditions and highlight the differential over-dispersion results in 
the form of boxplots and MA plots, shown in 
Figures \@ref(fig:over-dispersion-result) and 
\@ref(fig:over-dispersion-boxplot).

```{r over-dispersion-result, fig.cap="Over-dispersion log fold change (naive relative to active) is plotted against mean expression."}
# Select genes with no changes in mean expression
TableMean0 <- format(Test_DE_LFC0, Which = "Mean", Filter = FALSE)
ind_nochange <- TableMean0$ResultDiffMean == "NoDiff"
TableDisp0 <- format(Test_DE_LFC0, Which = "Disp", Filter = FALSE)

BASiCS_PlotDE(Test_DE_LFC0, Parameters = "Disp", Plot = "MA")
```


```{r over-dispersion-boxplot, fig.cap="Boxplot of over-dispersion log fold changes across all genes. The red line indicates a value of zero, corresponding to no difference."}
# Boxplot
wilcox.test(TableDisp0$DispLog2FC[ind_nochange])
boxplot(TableDisp0$DispLog2FC[ind_nochange],
  ylab = "LFC in over-dispersion", outline = FALSE
)
abline(a = 0, b = 0, lwd = 2, col = "dark red")

wilcox.test(TableDisp0$DispLog2FC[ind_nochange])
```

With this analysis, we detect increased over-dispersion in naive CD4^+^ T cells
for genes that show similar expression levels between naive and activated 
CD4^+^ T cells.

While the analysis in the previous section is well suited to detect global 
changes in variability (e.g. detecting if one cell population overall displays
higher expression variabilty), it does not allow the testing of changes in 
mean expression and expression variability in parallel.
For this, `r Biocpkg("BASiCS")` compares the residual over-dispersion 
parameters, which do not scale with mean expression, between the two conditions.
Here, we remove genes that are lowly expressed in both conditions.

```{r res-over-disp-filtering}
# exclude lowly expressed genes
high_expr <- TableMean$Mean1 > 1 & TableMean$Mean2 > 1
```

We can now perform differential expression testing as shown above.
Again, we use a LFC threshold higher than the default to capture only large
changes in mean expression.

```{r DE-DV-testing}
# Perform differential testing
Test_DE <- BASiCS_TestDE(
  Chain1 = chain_naive,
  Chain2 = chain_active,
  EpsilonM = log2(2),
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  CheckESS = TRUE,
  MinESS = 100,
  Plot = FALSE,
  PlotOffset = FALSE,
  GenesSelect = high_expr
)
```

We can now visualise the changes in residual over-dispersion between naive and 
activated CD4^+^ T cells in the form of a MA-plot 
(Figure \@ref(fig:diff-res-plot)).
In this visualisation, the difference between the posterior medians of the 
residual over-dispersion parameters $\epsilon$ are shown on the y-axis.
Epsilon values for genes that are not expressed in at least 2 cells per 
conditions are marked as `NA` and are therefore not being displayed.

```{r diff-res-plot, fig.cap="Distance of residual over-dispersion in naive cells relative to active cells. Colour indicates whether genes were excluded from testing, and whether a significant difference was identified between the two groups for that gene."}
TableResDisp <- format(Test_DE, Which = "ResDisp", Filter = FALSE)
BASiCS_PlotDE(Test_DE, Parameters = "ResDisp", Plot = "MA")
```

While one could focus on the genesets that show significant changes in
residual over-dispersion, here, we want to highlight how to analyse 
changes in mean expression in parallel to changes in variability.
For this, we will first combine the results of the differential mean expression 
and the differential residual over-dispersion test.
We will further remove the genes that were excluded from the test and those 
that are not expressed in at least 2 cells in either condition.

```{r combine-results}
cols <- setdiff(colnames(TableResDisp), c("GeneName", "MeanOverall"))
res_df <- cbind(TableMean, TableResDisp[, cols])
ind_exclude <- res_df$ResultDiffResDisp == "ExcludedByUser" |
  res_df$ResultDiffResDisp == "ExcludedFromTesting"
res_df <- res_df[!ind_exclude, ]
```

Next, we can visualise the regulation of each individual gene based on its 
changes in mean expression and expression variability
(Figure \@ref(fig:DV-DE-vis)).

```{r DV-DE-vis, fig.cap="Difference in residual over-dispersion is plotted against log fold change for all genes. Colour indicates whether significant differences were detected between the groups for each parameter."}
res_df$ResultDiffMean[grep("Excluded", res_df$ResultDiffMean)] <- "NoDiff"
res_df$ResultDiffResDisp[grep("Excluded", res_df$ResultDiffResDisp)] <- "NoDiff"
ggplot(res_df) +
  geom_point(
    aes(
      MeanLog2FC,
      ResDispDistance,
      colour = interaction(ResultDiffMean, ResultDiffResDisp, sep = ", ")
    ),
    alpha = 0.8,
    shape = 16
  ) +
  scale_colour_brewer(name = "Categories", palette = "Paired") +
  labs(x = bquote(log[2](FC)), y = "Difference in residual over-dispersion")
```

As discussed [previously](#vis-diff-exp), it is useful to visualise the results
of differential expression tests in order to appraise the quality of the 
results, and to identify systematic patterns among the genes identified.
For this purpose, we again use `r Biocpkg("ComplexHeatmap")`; the result is
shown in Figure \@ref(fig:heatmap-diffresdisp).



```{r heatmap-diffresdisp, fig.width = 7, fig.height = 5, fig.cap="Heatmap of 30 genes with higher residual over-dispersion in naive or active cells. Colour indicates expression level; colour bars on the right of heatmap segments indicate the residual over-dispersion for each gene in that population."}
# More variable in naive
ind_n <- TableResDisp$ResultDiffResDisp == "Naive+"
naive_resdisp <- TableResDisp[ind_n, ]
ord <- order(naive_resdisp$ResDispDistance, decreasing = FALSE)
naive_resdisp <- naive_resdisp[ord, ]
naive_resdisp$Symbol <- genenames[naive_resdisp$GeneName, 2]

# More variable in active
ind_a <- TableResDisp$ResultDiffResDisp == "Active+"
active_resdisp <- TableResDisp[ind_a, ]
ord <- order(active_resdisp$ResDispDistance, decreasing = TRUE)
active_resdisp <- active_resdisp[ord, ]
active_resdisp$Symbol <- genenames[active_resdisp$GeneName, 2]

heatmap_ngenes <- 15
heatmap_seq <- seq_len(heatmap_ngenes)

## Select genes with largest probability of differential variability
active_ind <- order(active_resdisp$ProbDiffResDisp, decreasing = TRUE)[heatmap_seq]
active_resdisp <- active_resdisp[active_ind, ]
## Subset count matrices to genes with highest probability
act_counts_act <- counts(sce_active)[active_resdisp$GeneName, ]
nai_counts_act <- counts(sce_naive)[active_resdisp$GeneName, ]

## Select genes with largest probability of differential variability
s_ind <- order(naive_resdisp$ProbDiffResDisp, decreasing = TRUE)[heatmap_seq]
naive_resdisp <- naive_resdisp[s_ind, ]
## Subset count matrices to genes with highest probability
act_counts_nai <- counts(sce_active)[naive_resdisp$GeneName, ]
nai_counts_nai <- counts(sce_naive)[naive_resdisp$GeneName, ]

## Calculate max values for colour scale
all_resdisp <- c(
  active_resdisp$ResDisp1, active_resdisp$ResDisp2,
  naive_resdisp$ResDisp1, naive_resdisp$ResDisp2
)
max_range <- max(abs(all_resdisp))
## colour scale symmetric around zero
colour <- colorRamp2(seq(-max_range, max_range, length.out = 9),
  rev(brewer.pal(9, "RdBu")))

## Combine count matrices by cell type
counts_active <- rbind(act_counts_act, act_counts_nai)
counts_naive <- rbind(nai_counts_act, nai_counts_nai)

## Split heatmaps using gene categories
split <- data.frame(
  Upregulated = c(
    rep("More variable \nin active", nrow(act_counts_act)),
    rep("More variable \nin naive", nrow(act_counts_nai))
  )
)
syms <- genenames[rownames(counts_active), 2]

fontsize <- 7
Heatmap(
  log10(counts_naive + 1),
  row_labels = syms,
  row_names_gp = gpar(fontsize = fontsize),
  name = "log10(count + 1)",
  column_dend_height = unit(0.2, "npc"),
  column_title_side = "bottom",
  column_title = "Naive cells",
  cluster_rows = FALSE,
  show_column_names = FALSE,
  split = split,
  right_annotation = rowAnnotation(
    epsilon = c(active_resdisp$ResDisp1, naive_resdisp$ResDisp1),
    col = list(epsilon = colour)
  ),
  col = viridis(100)) +
Heatmap(
  log10(counts_active + 1),
  row_labels = syms,
  column_dend_height = unit(0.2, "npc"),
  row_names_gp = gpar(fontsize = fontsize),
  column_title = "Active cells",
  column_title_side = "bottom",
  show_column_names = FALSE,
  name = "log10(count + 1)",
  split = split,
  right_annotation = rowAnnotation(
    epsilon = c(active_resdisp$ResDisp2, naive_resdisp$ResDisp2),
    col = list(epsilon = colour)
  ),
  cluster_rows = FALSE,
  col = viridis(100))
```

## Using BASiCS without spike-in genes

### Inference using BASiCS without spike-in genes

`r Biocpkg("BASiCS")`, when using spike-in molecules, utilises a vertical 
integration framework.
Under this framework, spike-in genes are used as a reference in order to
aid normalisation, based on the knowledge that the original quantity of spike-in
molecules was approximately equal in each well.
@Eling2018 introduced a novel method of inferring gene expression profiles
using `r Biocpkg("BASiCS")` without relying on spike-in genes to quantify 
technical noise.
In this horizontal integration framework, technical variation is quantified 
using replication [@Carroll2005]. 
In the absence of true technical replicates, we assume that
population-level characteristics of the cells are replicated using appropriate
experimental design. This requires that cells from the same population
have been randomly allocated to different batches. Given appropriate 
experimental design, `r Biocpkg("BASiCS")` assumes that biological effects
are shared across batches, while technical variation leads to spurious 
differences between cells in different batches.

Using `r Biocpkg("BASiCS")` without spike-in genes is a very similar process 
to the process of using it with spike-in genes. We will demonstrate using the 
naive cells. First, we must ensure that a `BatchInfo` field is present in the 
`SingleCellExperiment` used as input. In this case we use individual of origin 
as the batch vector.

```{r MCMC-naive-nospikes, eval = FALSE}
chain_naive_nospikes <- BASiCS_MCMC(
  Data = sce_naive,
  PrintProgress = FALSE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  StoreChains = TRUE,
  StoreDir = "rds/", 
  RunName = "naive_nospikes",
  WithSpikes = FALSE
)
```

```{r download-chain-naive-nospikes}
if (!file.exists("rds/chain_naive_nospikes.Rds")) {
  download.file(
    "https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/raw/master/chain_naive_nospikes.Rds",
    destfile = "rds/chain_naive_nospikes.Rds"
  )
}
chain_naive_nospikes <- readRDS("rds/chain_naive_nospikes.Rds")
```

The resulting `BASiCS_Chain` object produced using this horizontal integration
framework is functionally similar to one produced using the vertical integration
framework. It can be used in place of the `BASiCS_Chain` objects produced using
the vertical integration approach, as described above.

As discussed previously, it is important to ensure that an adequate effective
sample size has been generated using MCMC.
Figure \@ref(fig:diag-plot-naive-nospikes) shows that the sampler has generated
a large effective sample size for most parameters, similar to the case when we 
included spike-in molecules.


```{r diag-hist-naive-nospikes, fig.cap="Distribution of effective sample size across all genes for mean and over-dispersion parameters using the horizontal integration approach.", eval=FALSE, echo=FALSE}
mu_ess <- BASiCS_DiagHist(chain_naive, Param = "mu") +
  xlab("ESS: mu")
delta_ess <- BASiCS_DiagHist(chain_naive, Param = "delta") +
  xlab("ESS: delta")
multiplot(mu_ess, delta_ess, cols = 2)
```

```{r diag-plot-naive-nospikes, fig.cap="Effective sample size is plotted against parameter estimates for mean and over-dispersion parameters using the horizontal integration approach. Colour indicates local density, with lighter colours representing higher density."}
mu_ess2 <- BASiCS_DiagPlot(chain_naive, Param = "mu") +
  theme(legend.position = "bottom")
delta_ess2 <- BASiCS_DiagPlot(chain_naive, Param = "delta") +
  theme(legend.position = "bottom")
multiplot(mu_ess2, delta_ess2, cols = 2)
```

### Comparison of parameter estimates when using spike-ins and when not-using spike-ins

Under the horizontal integration approach described above,
the scale of mean expression parameters and global scaling factors is not 
jointly identifiable, in that a global shift in mean expression parameters 
could be exactly offset by an equivalent shift in cell-specific normalisation
parameters. Therefore, the geometric mean of the mean expression parameters
is fixed to a constant value. Relative expression level estimates are broadly 
consistent between the horizontal and vertical integration approaches; 
however there may be a global difference in mean expression estimates, as shown
in Figure \@ref(fig:offset). It is important to remove this global scale offset
before performing comparative analyses. This is performed by default in
`BASiCS_TestDE`, but can be performed manually using `BASiCS_CorrectOffset`.

```{r offset, fig.cap="Distribution of mean expression values before and after correcting the global difference in scale."}
BASiCS_PlotOffset(chain_naive_nospikes, chain_naive,
  GroupLabel1 = "No spike-ins", GroupLabel2 = "Spike-ins",
  Type = "before-after")
offset <- BASiCS_CorrectOffset(chain_naive_nospikes, chain_naive)
chain_naive_nospikes_offset <- offset$Chain
chain_naive_nospikes_offset
```

Following removal of the global offset, the mean expression and over-dispersion 
estimates obtained from each method are directly comparable.
As seen in Figures \@ref(fig:mu-spike-comp) and 
\@ref(fig:delta-spike-comp), parameter point estimates from the two 
methods are highly correlated.

```{r mu-spike-comp, fig.cap="Comparison of mean expression point estimates using spike-in genes, and the same parameters estimated without using spike-in genes."}
mu_spikes <- displayChainBASiCS(chain_naive)
mu_nospikes <- displayChainBASiCS(chain_naive_nospikes_offset)
ggplot(mapping = aes(colMedians(mu_spikes), colMedians(mu_nospikes))) +
  geom_pointdensity() +
  scale_colour_viridis() +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    x = "Mean expression (with spike-ins)",
    y = "Mean expression (without spike-ins)"
  )
```

```{r delta-spike-comp, fig.cap="Comparison of over-dispersion point estimates using spike-in genes, and the same parameters estimated without using spike-in genes."}
delta_spikes <- displayChainBASiCS(chain_naive, Param = "delta")
delta_nospikes <- displayChainBASiCS(chain_naive_nospikes_offset, Param = "delta")
ggplot(mapping = aes(colMedians(delta_spikes), colMedians(delta_nospikes))) +
  geom_pointdensity() +
  scale_colour_viridis() +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    x = "Over-dispersion (with spike-ins)",
    y = "Over-dispersion (without spike-ins)"
  )
```



# Discussion 

In this article, we have explored the research questions that 
`r Biocpkg("BASiCS")` seeks to 
resolve --- chiefly, robustly quantifying average and variability in
expression in cell populations. We have outlined the appropriate quality control
and data visualisation steps to take when undertaking an analysis using 
`r Biocpkg("BASiCS")`
in order to ensure high quality input data.
We have also outlined the steps needed to use `r Biocpkg("BASiCS")`
to quantify biological variability, identify highly variable genes, and
normalise scRNAseq data from a single population. We have also provided a 
limited comparison of the results of these analyses using `r Biocpkg("BASiCS")`
and the result of similar analyses using `r Biocpkg("scran")`.
Furthermore, we have demonstrated functions within `r Biocpkg("BASiCS")`
that allow users to ensure the MCMC used in `r Biocpkg("BASiCS")`
has convergend and produced adequate sample sizes. Finally, we have 
demonstrated the use of `r Biocpkg("BASiCS")` to robustly identify 
differentially expressed genes, in terms of mean expression and in terms of 
biological variability.

Further challenges exist in analysing scRNAseq data [@Eling2019;@Lahnemann2020].
For `r Biocpkg("BASiCS")`, the primary challenge currently is computational 
efficiency. The number of cells profiled in scRNAseq experiments has scaled 
exponentially since the development of the technology [@Svensson2018].
Given that `r Biocpkg("BASiCS")` requires computationally intensive
MCMC sampling to estimate the posterior distribution, it becomes computationally
intractable to analyse data from very large numbers of cells.
We intend to update this workflow as the field evolves, and as we adress the 
issues and challenges outlined here.


# Reproducibility

The following software versions were used throughout this workflow:

- **R version**: `r R.version.string`

- **Bioconductor version**: `r BiocManager::version()`

- **R packages**: 
  - BASiCS `r packageVersion("BASiCS")`
  - scran `r packageVersion("scran")`
  - scater `r packageVersion("scater")`  
  Version 
  numbers for all remaining packages is available at [Session Info](#session-info).

A Docker image containing all software requirements is available at 
[Docker hub](https://hub.docker.com/repository/docker/alanocallaghan/bocker).


# Session Info {#session-info}

```{r, session-info}
sessionInfo()
```


<!-- 

# Software version

**TODO: Versions of all main Bioconductor packages**  
*I think sessionInfo suffices.*
 -->


# Data availability

**TODO: Links to Grun data and Ximenas data**
**TODO: Links to MCMC chains**


# Software availability

**TODO: Software: All software used in this workflow is available as part of 
Bioconductor X.Y**  
**TODO: The source code of this workflow is available from: YYY**  
**TODO: Link to Github release version, source code**  
**TODO: License: ask Aaron** (creative commons attribution?)

This section will be generated by the Editorial Office before publication. 
Authors are asked to provide some initial information to assist the 
Editorial Office, as detailed below.

1. URL link to where the software can be downloaded from or used by a non-coder
  (AUTHOR TO PROVIDE; optional)
2. URL link to the author's version control system repository containing the 
  source code (AUTHOR TO PROVIDE; required)
3. Link to source code as at time of publication (*F1000Research* TO GENERATE)
4. Link to archived source code as at time of publication (*F1000Research* 
  TO GENERATE)
5. Software license (AUTHOR TO PROVIDE; required)


# Author information

In order to give appropriate credit to each author of an article, the 
individual contributions of each author to the manuscript should be detailed in 
this section. We recommend using author initials and then stating briefly how 
they contributed.

# Competing interests

No competing interests were disclosed.

# Grant information
Please state who funded the work discussed in this article, whether it is your 
employer, a grant funder etc. Please do not list funding that you have that is 
not relevant to this specific piece of research. For each funder, please state 
the funder’s name, the grant number where applicable, and the individual to 
whom the grant was assigned. If your work was not funded by any grants, 
please include the line: 'The author(s) declared that no grants were involved 
in supporting this work.'

# Acknowledgments
This section should acknowledge anyone who contributed to the research or the 
article but who does not qualify as an author based on the criteria provided 
earlier (e.g. someone or an organization that provided writing assistance). 
Please state how they contributed; authors should obtain permission to 
acknowledge from all those mentioned in the Acknowledgments section.

Please do not list grant funding in this section.
