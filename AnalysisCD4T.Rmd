---
title: "Transcriptional variability analysis of CD4^+^ T cells using BASiCS"
author: 
  - name: Alan O'Callaghan
    affiliation: 
    - &MRC MRC Human Genetics Unit, Institute of Genetics \& Cancer, 
      University of Edinburgh, Western General Hospital, Crewe Road, Edinburgh, 
      EH4 2XU, UK
    email: "a.b.o'callaghan@sms.ed.ac.uk"
  - name: Nils Eling
    affiliation: 
    - &UZH Department of Quantitative Biomedicine, University of Zurich,
      Winterthurerstrasse 190, CH-8057, Zurich, Switzerland
    - &ETH Institute for Molecular Health Sciences, ETH Zurich,
      Otto-Stern Weg 7, 8093 Zurich, Switzerland
  - name: John C. Marioni
    affiliation: 
    - &EBI European Molecular Biology Laboratory, European Bioinformatics 
      Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD, UK
    - &CRUK Cancer Research UK Cambridge Institute, University of Cambridge, 
      Li Ka Shing Centre, Cambridge, CB2 0RE, UK
  - name: Catalina A. Vallejos
    affiliation: 
    - *MRC 
    - The Alan Turing Institute, British Library, 96 Euston Road, London, 
      NW1 2DB, UK
    email: catalina.vallejos@igmm.ed.ac.uk
bibliography: Workflow.bib
urlcolor: Orange
output:
  BiocWorkflowTools::f1000_article:
    fig_width: 6
    fig_height: 4
---


```{r setup_knitr, include = FALSE, cache = FALSE}
library("BiocStyle")
library("knitr")
knitr::opts_chunk$set(
  message = FALSE, error = FALSE, warning = FALSE,
  cache = 0, cache.path = "cache_supp/",
  fig.path = "figure_supp/"
)
```

# Introduction

As a case study, we use scRNA-seq data generated for CD4^+^ T cells using the 
C1 Single-Cell Auto Prep System (FluidigmÂ®). @Martinez-jimenez2017 profiled 
naive (hereafter also referred to as unstimulated) and activated (three hours 
using in vitro antibody stimulation) CD4^+^ T cells from young and old animals 
across two mouse strains to study changes in expression variability during 
ageing and upon immune activation. They extracted naive or effector memory 
CD4^+^ T cells from spleens of young or old animals, obtaining purified 
populations using either magnetic-activated cell sorting (MACS) or fluorescence 
activated cell sorting (FACS). External ERCC spike-in RNA18 was added to aid 
the quantification of technical variability across all cells and all experiments 
were performed in replicates (hereafter also referred to as batches).

Here, we load the required software packages:

```{r}
# Data visualisation
library("ggplot2")
library("ggpointdensity")
library("patchwork")
library("ComplexHeatmap")
# colour scales
library("viridis")
library("circlize")
library("RColorBrewer")
# Data manipulation
library("reshape2")
library("tidyr")
# To load excel files
library("readxl")
# To obtain summary statistics
library("sparseMatrixStats")
# To assess convergence of the algorithm implemented in BASiCS
library("coda")
# Single cell specific libraries
library("SingleCellExperiment")
library("scater")
library("scran")
library("BASiCS")
```

# Data pre-processing and quality control steps

## Downloading the data

The matrix with raw read counts can be obtained from ArrayExpress under the 
accession number 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/).
In the matrix, column names contain library identifiers and row names
display Ensembl gene identifiers.

```{r naive-data}
if (!file.exists("downloads/")) {
  dir.create("downloads", showWarnings = FALSE)
}
if (!dir.exists("downloads/MarioniLab-ImmuneAging2017-5b665d1")) {
  website <- "https://zenodo.org/"
  folder <- "record/3522970/files/MarioniLab/"
  file <- "ImmuneAging2017-1.0.0.zip"
  download.file(
    paste0(website, folder, file),
    destfile = "downloads/ImmuneAging2017-1.0.0.zip"
  )
  unzip("downloads/ImmuneAging2017-1.0.0.zip", exdir = "downloads")
}
cd4_raw <- read.table(
  "downloads/MarioniLab-ImmuneAging2017-5b665d1/Data/raw_data.txt",
  header = TRUE,
  sep = "\t"
)
cd4_raw <- as.matrix(cd4_raw)
```

The input matrix contains data for `r format(ncol(cd4_raw), big.mark=",")`
cells and `r format(nrow(cd4_raw), big.mark=",")`
genes, including `r sum(grepl("ERCC", rownames(cd4_raw)))` ERCC spike-ins.

Information about experimental conditions and other metadata is available 
under the same accession number. 

```{r selecting-serum-cells}
cd4_metadata <- read_xlsx(
  "downloads/MarioniLab-ImmuneAging2017-5b665d1/Data/metadata.xlsx"
)
cd4_metadata <- as.data.frame(cd4_metadata)

## Save sample identifiers as rownames
rownames(cd4_metadata) <- cd4_metadata$CellName
```

The columns in the metadata file contain library identifiers (`X`), strain 
information (`Strain`; *Mus musculus castaneus* or *Mus musculus domesticus*), 
the age of the animals (`Age`; young or old), stimulation state of the cells 
(`Stimulus`; naive or activated), batch information (`Individuals`; associated 
to different mice), and cell type information (`Celltype`; via FACS or MACS 
purification). 

Here, we convert the data and metadata described above into a 
`SingleCellExperiment` object. 
For this purpose, we first separate the input matrix of expression counts into
two matrices associated to intrinsic genes and external spike-ins, respectively. 
Within the `SingleCellExperiment` object, the latter is stored separately
as an *alternative experiment*. For more details on the alternative experiment
slot, see `help("altExp")`.


```{r CD4-SCE-object}
## Separate intrinsic from ERCC counts
bio_counts <- cd4_raw[!grepl("ERCC", rownames(cd4_raw)), ]
spike_counts <- cd4_raw[grepl("ERCC", rownames(cd4_raw)), ]
## Generate the SingleCellExperiment object
sce_cd4_all <- SingleCellExperiment(
  assays = list(counts = bio_counts),
  colData = cd4_metadata[colnames(cd4_raw), ]
)
## Add read-counts for spike-ins as an alternative experiment
altExp(sce_cd4_all, "spike-ins") <- SummarizedExperiment(
  assays = list(counts = spike_counts)
)
```

Hereafter, our analysis focuses on naive CD4^+^ T cells in the presence and
absence of stimulation using plate-bound antibodies,+ obtained 
from young *Mus musculus domesticus* animals, and purified using MACS-based cell
sorting. 
Thus, we subset the `SingleCellExperiment` object to these 
`r sum(sce_cd4_all$Strain == "Mus musculus domesticus" & sce_cd4_all$Age == "Young" & sce_cd4_all$Celltype == "MACS-purified Naive")` cells.

```{r naive-activated-CD4-SCE-object}
ind_select <- sce_cd4_all$Strain == "Mus musculus domesticus" &
  sce_cd4_all$Age == "Young" &
  sce_cd4_all$Celltype == "MACS-purified Naive"
sce_naive_active <- sce_cd4_all[, ind_select]
sce_naive_active
```


## Gene annotation

Input data was annotated using Ensembl gene identifiers. 
To facilitate interpretation, it is often useful to obtain a mapping from 
Ensembl gene IDs to gene symbols using the BioMart suite
([http://www.biomart.org](http://www.biomart.org)) via the 
Bioconductor package `r Biocpkg("biomaRt")` [@Durinck2009].
This can also be used to obtain gene-pathways mappings and other
metadata (e.g. gene length), useful for performing functional analysis
of gene sets identified in downstream analyses.

```{r obtain-gene-symbols}
# Check if data storage folder exists and create it if needed
if (!dir.exists("rds")) {
  dir.create("rds", showWarnings = FALSE)
}
if (!file.exists("rds/genenames.Rds")) {
  # Initialize mart and dataset
  ensembl <- useEnsembl(
    biomart = "genes",
    version = 104,
    dataset = "mmusculus_gene_ensembl"
  )
  # Select gene ID and gene name
  genenames <- getBM(
    attributes = c("ensembl_gene_id", "external_gene_name", "gene_biotype", 
                   "chromosome_name", "description"),
    mart = ensembl
  )
  rownames(genenames) <- genenames$ensembl_gene_id
  # Store information for future use
  saveRDS(genenames, "rds/genenames.Rds")
}
# Load pre-downloaded gene annotation information
genenames <- readRDS("rds/genenames.Rds")
```

We add this information as `rowData` within the `SingleCellExperiment` 
object created above. 

```{r}
## Merge biomaRt annotation
rowdata <- data.frame(ensembl_gene_id = rownames(sce_naive_active))
rowdata <- merge(rowdata, genenames, by = "ensembl_gene_id", all.x = TRUE)
rownames(rowdata) <- rowdata$ensembl_gene_id
## Check if  order is correct after merge;
stopifnot(all(rownames(rowdata) == rownames(sce_naive_active)))
## add to the SingleCellExperiment object
rowData(sce_naive_active) <- rowdata
```

For the remaining analysis, we will only focus on the 
`r format(sum(rowData(sce_naive_active)$gene_biotype == "protein_coding", na.rm=TRUE), big.mark=",")`
protein coding genes that are contained in the data. These are selected below. 

```{r}
protein_coding <- which(
  rowData(sce_naive_active)$gene_biotype == "protein_coding"
)
sce_naive_active <- sce_naive_active[protein_coding, ]
```

## QC and exploratory data analysis

The data available at 
[E-MTAB-4888](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4888/) have
been already filtered to remove poor quality samples.
The QC applied in [@Martinez-jimenez2017] removed cells with: (i) fewer 
than 1,000,000 total reads, (ii) less than 20% of reads mapped to 
endogenous genes, (iii) less than 1,250 or more than 3,000 detected genes and 
(iv) more than 10% or fewer than 0.5% of reads mapped to mitochondrial genes.
We include visualisations of these measures here; we also include another 
widely used QC diagnostic plot that compares the total 
number (or fraction) of spike-in counts versus the total number (or fraction) of 
endogeneous counts.
In such a plot, low quality samples are characterised by a high fraction of 
spike-in counts and a low fraction of endogeneous counts 
(see Figure \@ref(fig:PerCellQC)).

```{r PerCellQC, fig.cap="Cell-level QC metrics. The total number of endogenous read-counts (excludes non-mapped and intronic reads) is plotted against the total number of detected genes (left) and the total number of spike-in read-counts (right)."}
sce_naive_active <- addPerCellQC(sce_naive_active, use_altexps = TRUE)
p_cell_qc1 <- plotColData(
  sce_naive_active,
  x = "sum",
  y = "detected") +
  xlab("Total endogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(axis.text.x = element_text(hjust = 1, angle = 45))
p_cell_qc2 <- plotColData(
  sce_naive_active,
  x = "sum",
  y = "altexps_spike-ins_sum") +
  xlab("Total endogenous reads per cell") +
  ylab("Total spike-in reads per cell") +
  theme(axis.text.x = element_text(hjust = 1, angle = 45))
p_cell_qc1 + p_cell_qc2
```

We can also visualise these metrics with respect to cell-level metadata, such
as the experimental conditions (active vs unstimulated) and the different mice 
from which cells were collected 
(see Figure \@ref(fig:experimental-condition-batch)). 

```{r experimental-condition-batch, fig.cap="Cell-level QC metrics according to cell-level metadata. The total number of endogenous reads (excludes non-mapped and intronic reads) is plotted against the total number of detected genes. Colour indicates the experimental condition (left) and animal of origin (right) for each cell."}
p_stimulus <- plotColData(
    sce_naive_active,
    x = "sum",
    y = "detected",
    colour_by = "Stimulus"
  ) +
  xlab("Total endogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
p_batch <- plotColData(
    sce_naive_active,
    x = "sum",
    y = "detected",
    colour_by = "Individuals"
  ) +
  xlab("Total endogenous reads per cell") +
  ylab("Number of detected genes per cell") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
p_stimulus + p_batch
```

To further explore the underlying structure of the data, we perform global
scaling normalisation using `r Biocpkg("scran")` and
principal component analysis (PCA) of log-transformed normalised expression 
counts using `r Biocpkg("scater")`.
As seen in Figure \@ref(fig:pca-visualisation-stimulus-batch), this analysis 
suggests the absence of strong batch effects.
It should be noted that the estimation of global scaling normalisation factors 
using `r Biocpkg("scran")` is not strictly necessary in the 
`r Biocpkg("BASiCS")` workflow. 
Here, we only use it as part of the exploratory data analysis. 
Moreover, count-based models for dimensionality reduction 
(e.g. [@Townes2019;@Lopez2018]) could be used as an alternative to PCA, 
removing the need for log normalisation.

```{r pca-visualisation-stimulus-batch, fig.cap="First two principal components of log-transformed expression counts after scran normalisation. Colour indicates the experimental condition (left) and animal of origin (right) for each cell."}
## Global scaling normalisation + log tranformation + PCA
sce_naive_active <- computeSumFactors(sce_naive_active)
sce_naive_active <- logNormCounts(sce_naive_active)
sce_naive_active <- runPCA(sce_naive_active)
p_stimulus <- plotPCA(sce_naive_active, colour_by = "Stimulus") +
  theme(legend.position = "bottom")
p_batch <- plotPCA(sce_naive_active, colour_by = "Individuals") +
  theme(legend.position = "bottom")
p_stimulus + p_batch
```

In addition to cell-specific QC, we also recommend a gene filtering 
step prior to using `r Biocpkg("BASiCS")`. 
The purpose of this filter is to remove lowly expressed genes that were largely
undetected through sequencing, making reliable variability estimates difficult
to obtain.
Here, we remove genes that are not detected in at least 20 cells across both
conditions, or that have an average read count below 1. 
These thresholds can vary across datasets and should be 
informed by gene-specific QC metrics such as those shown in
Figure \@ref(fig:gene-selection) as well as prior knowledge about the cell types
and conditions being studied, where available.

```{r cd4-gene-selection, fig.cap="Average read-count for each gene is plotted against the number of cells in which that gene was detected. Dashed grey lines are shown at the thresholds below which genes are removed."}

## Add QC measures based on features
sce_naive_active <- addPerFeatureQC(sce_naive_active, exprs_values = "counts")

## Remove genes with zero total counts across all cells
sce_naive_active <- sce_naive_active[rowData(sce_naive_active)$detected != 0, ]

## Transform "detected" into number of cells and define inclusion criteria
rowData(sce_naive_active)$detected_cells <-
  rowData(sce_naive_active)$detected * ncol(sce_naive_active) / 100

## define thresholds for genes based on QC measures
detected_threshold <- 20
mean_threshold <- 1

## apply thresholds
include_gene <- rowData(sce_naive_active)$mean >= mean_threshold &
  rowData(sce_naive_active)$detected_cells >= detected_threshold

## add gene QC filter to rowdata for visualisation
rowData(sce_naive_active)$include_gene <- include_gene

## plot gene QC filter
plotRowData(
    sce_naive_active,
    x = "detected_cells",
    y = "mean",
    colour_by = "include_gene"
  ) +
  xlab("Number of cells in which expression was detected") +
  ylab("Average number of read counts across all cells") +
  scale_x_log10() +
  scale_y_log10() +
  theme(legend.position = "bottom") +
  geom_vline(
    xintercept = detected_threshold,
    linetype = "dashed",
    col = "grey60"
  ) +
  geom_hline(
    yintercept = mean_threshold,
    linetype = "dashed",
    col = "grey60"
  )

## Apply gene QC filter
sce_naive_active <- sce_naive_active[rowData(sce_naive_active)$include_gene, ]
```

Subsequently, we also require users to remove spike-in molecules that were not 
captured through sequencing. We do this separately for naive and active
cells.

```{r spike-ins-present}
ind_active <- sce_naive_active$Stimulus == "Active"
ind_naive <- sce_naive_active$Stimulus == "Unstimulated"
spikes <- assay(altExp(sce_naive_active))
detected_spikes_active <- rowSums(spikes[, ind_active] > 0) > 0
detected_spikes_naive <- rowSums(spikes[, ind_naive] > 0) > 0
detected_spikes <- detected_spikes_naive & detected_spikes_active
altExp(sce_naive_active) <- altExp(sce_naive_active)[detected_spikes, ]
```

## Spike-in concentrations

If spike-ins will be used to aid data normalisation and technical noise 
quantification, `r Biocpkg("BASiCS")` also requires the number of spike-in 
molecules that were added to each well. 
For each spike-in $i$, this corresponds to:

$$ \mu_{i} = C_i \times 10^{-18} \times (6.022 \times 10^{23}) 
\times V \times D \hspace{0.5cm} \mbox{where,} $$

- $C_i$ is the concentration for the spike-in $i$ (measured in $aM\mu{}l^{-1}$),
- $V$ is the volume added into each well (measure in $nl$) and
- $D$ is a dilution factor. 

The remaining factors in the equation above are unit conversion constants
(e.g. from moles to molecules). 
For the CD4^+^ T cell data, the authors added a 1:50,000 dilution of the ERCC 
spike-in mix 1 and a volume of $9nl$ was added into each well (see [https://www.fluidigm.com/faq/ifc-9](https://www.fluidigm.com/faq/ifc-9)).
Finally, input concentrations $C_i$ can be downloaded with the Bioconductor
package `r Biocpkg("scRNAseq")`, using the function
`ERCCSpikeInConcentrations()`.

Based on this information, we can use `BASiCS_CalculateERCC` to calculate
the amount of spike-in molecules in each well:

```{r, ercc-mul}
ERCC_count <- BASiCS_CalculateERCC(Mix = 1, DilutionFactor = 1/50000, VolumePerCell = 0.009)
```

To update the `sce_naive` and `sce_active` objects, the user must create a 
`data.frame` whose first column contains the spike-in labels (e.g. ERCC-00130) 
and whose second column contains the number of molecules calculated above.
We add this as row metadata for `altExp(sce_naive)` and 
`altExp(sce_active)`. 

```{r spike-info}
SpikeInput <- data.frame(
  Names = names(ERCC_count),
  count = ERCC_count
)
## Exclude spike-ins not included in the input SingleCellExperiment objects
ind_match <- match(rownames(altExp(sce_naive_active)), SpikeInput$Names)
SpikeInput <- SpikeInput[ind_match , ]
## Add as metadata
rowData(altExp(sce_naive_active)) <- SpikeInput
```

The final dataset used in subsequent analyses contains 
`r ncol(sce_naive_active)` cells, `r nrow(sce_naive_active)` genes and 
`r nrow(altExp(sce_naive_active))` spike-ins.

```{r save-SCE}
ind_active <- sce_naive_active$Stimulus == "Active"
ind_naive <- sce_naive_active$Stimulus == "Unstimulated"
sce_naive <- sce_naive_active[, ind_naive]
sce_active <- sce_naive_active[, ind_active]
```

# Running the BASiCS model

Here, we fit the BASiCS model using two separate versions. The first version 
uses technical spike-in to aid global scaling normalisation and technical 
noise quantification. The second version ignores spike-in genes. Instead,
technical noise is quantified by borrowing information across the different
batches of cells. The latter is based on the horizontal integration approach
described by @Eling2018.

## Inference using spike-ins

```{r, eval = FALSE}
set.seed(42)
chain_naive <- BASiCS_MCMC(
  Data = sce_naive,
  PrintProgress = TRUE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  Threads = 4,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "naive",
  WithSpikes = FALSE
)
set.seed(43)
chain_active <- BASiCS_MCMC(
  Data = sce_active,
  PrintProgress = TRUE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  Threads = 4,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "active",
  WithSpikes = FALSE
)
```

## Inference using BASiCS without spike-ins

Using `r Biocpkg("BASiCS")` without spike-ins is very similar to using it
with spike-ins. We will demonstrate using the
naive cells. However, first, we must ensure that a `BatchInfo` field is present
in the `SingleCellExperiment` used as input. In this case we use individual
of origin as the batch vector.

```{r MCMC-naive-nospikes, eval = FALSE}
set.seed(44)
chain_naive_nospikes <- BASiCS_MCMC(
  Data = sce_naive,
  PrintProgress = TRUE,
  N = 40000,
  Thin = 20,
  Burn = 20000,
  Regression = TRUE,
  Threads = 4,
  StoreChains = TRUE,
  StoreDir = "rds/",
  RunName = "naive_nospikes",
  WithSpikes = FALSE
)
```

## Loading pre-run MCMC chains

Each of the runs above is time consuming (a few hours in a typical laptop). 
Hence, for convenience, we have uploaded our chains to a 
[Zenodo repository](https://doi.org/10.5281/zenodo.5243265). These can be 
downloaded and used as the input for subsequent analyses. 

```{r download-chain-naive-nospikes}
chains_website <- "https://git.ecdf.ed.ac.uk/vallejosgroup/basicsworkflow2020/-/raw/master/"
# chains_website <- "https://zenodo.org/record/5243265/files/"

options(timeout = 1000)
if (!file.exists("rds/chain_naive.Rds")) {
  download.file(
    paste0(chains_website, "rds/chain_naive.Rds"),
    destfile = "rds/chain_naive.Rds"
  )
}
if (!file.exists("rds/chain_active.Rds")) {
  download.file(
    paste0(chains_website, "rds/chain_active.Rds"),
    destfile = "rds/chain_active.Rds"
  )
}
if (!file.exists("rds/chain_naive_nospikes.Rds")) {
  download.file(
    paste0(chains_website, "rds/chain_naive_nospikes.Rds"),
    destfile = "rds/chain_naive_nospikes.Rds"
  )
}
chain_naive <- readRDS("rds/chain_naive.Rds")
chain_active <- readRDS("rds/chain_active.Rds")
chain_naive_nospikes <- readRDS("rds/chain_naive_nospikes.Rds")
```

# MCMC convergence diagnosics

`r Biocpkg("BASiCS")` uses an adaptive Metropolis-within-Gibbs algorithm 
[@Roberts2009] to perform inference. Before interpreting the results, it is 
important to ensure that the algorithm has converged. There are multiple ways
to do this. In principle, we could visualise the history of iterations for 
each model parameter in order to assess convergence. However, this is impractical
as `r Biocpkg("BASiCS")` infers thousands of parameters. Instead, we use the
`BASiCS_DiagPlot()` to visualise diagnostic metrics calculated for each parameter. 
In particular, it can calculate the effective sample size and the Geweke 
diagnostic criteria [@Geweke1995]. 
For simplicity, here we only focus on the MCMC chains obtained for gene-specific
mean expression parameters ($\mu_i$) when analysing the naive CD4^+^ T cells with
spike-ins. However, a similar analysis must be applied to all other chains before 
they are used in downstream analysis.  

```{r diag-plot-naive, fig.cap="Effective sample size is plotted against parameter estimates for mean expression. As an illustration, we only consider the naive immune cells and the model with spike-ins. Colour indicates local density, with lighter colours representing higher density.", eval = FALSE, echo = FALSE}
diag_p1 <- BASiCS_DiagPlot(chain_naive, Param = "mu", Measure = "geweke") +
  theme(legend.position = "bottom")
diag_p2 <- BASiCS_DiagPlot(chain_naive, Param = "mu", Measure = "ess") +
  theme(legend.position = "bottom")
diag_p1 + diag_p2 + plot_annotation(tag_levels = "A")

```

In this case, we can see positive evidence to support convergence of the MCMC:
most Geweke $Z$-scores are within the dashed lines and most genes have a high
effective sample size (above 500).

# Comparison of parameter estimates with and without spike-ins

Under the horizontal integration approach described above,
the scale of mean expression parameters and global scaling factors is not 
jointly identifiable, in that a global shift in mean expression parameters 
could be exactly offset by an equivalent shift in cell-specific normalisation
parameters. Therefore, the geometric mean of the mean expression parameters
is fixed to a constant value. Relative expression level estimates are broadly 
consistent between the horizontal and vertical integration approaches; 
however there may be a global difference in mean expression estimates, as shown
in Figure \@ref(fig:offset). It is important to remove this global scale offset
before performing comparative analyses. This is performed by default in
`BASiCS_TestDE`, but can be performed manually using `BASiCS_CorrectOffset`.

```{r offset, fig.cap="Distribution of mean expression values before and after correcting the global difference in scale."}
BASiCS_PlotOffset(chain_naive_nospikes, chain_naive,
  GroupLabel1 = "No spike-ins", GroupLabel2 = "Spike-ins",
  Type = "before-after")
offset <- BASiCS_CorrectOffset(chain_naive_nospikes, chain_naive)
chain_naive_nospikes_offset <- offset$Chain
chain_naive_nospikes_offset
```

A number of genes have very low expression estimates in the naive population,
due to the fact that they each have zero read counts across the entire naive
population; we therefore remove these genes before making a comparison.
Following removal of the global offset, the mean expression 
and over-dispersion estimates obtained from each method are directly comparable.
As seen in Figures \@ref(fig:spike-comp)A and 
\@ref(fig:spike-comp)B, parameter point estimates from the two 
methods are highly correlated. There is a tail of non-expressed genes with
very low mean expression level as inferred without spike-ins, comprising
those genes with no measured expression across the entire population.

```{r spike-comp, fig.cap="Comparison of point estimates using spike-ins, and the same parameters estimated without using spike-ins for mean expression (A) and over-dispersion (B). A dashed red line indicates the identity line, $y=x$. Genes with zero counts across all cells were excluded from the plot of mean expression parameters."}
mu_spikes <- displayChainBASiCS(chain_naive)
mu_nospikes <- displayChainBASiCS(chain_naive_nospikes_offset)

# Remove genes with zero counts across all cells and calculate medians
ind_nonzero <- rowSums(counts(sce_naive)) != 0
mu_spikes <- colMedians(mu_spikes[, ind_nonzero])
mu_nospikes <- colMedians(mu_nospikes[, ind_nonzero])

g1 <- ggplot() +
  aes(mu_spikes, mu_nospikes) +
  geom_pointdensity(alpha = 0.7) +
  scale_colour_viridis(name = "Density") +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(
    colour = "firebrick",
    linetype = "dashed",
    slope = 1,
    intercept = 0
  ) +
  labs(
    x = "Mean expression\n(with spike-ins)",
    y = "Mean expression\n(without spike-ins)"
  ) +
  theme(
    legend.position = "bottom",
    legend.text = element_text(angle = 45, size = 8, hjust = 0.5, vjust = 0.5)
  )

delta_spikes <- displayChainBASiCS(chain_naive, Param = "delta")
delta_nospikes <- displayChainBASiCS(chain_naive_nospikes_offset, Param = "delta")

g2 <- ggplot() +
  aes(colMedians(delta_spikes), colMedians(delta_nospikes)) +
  geom_pointdensity(alpha = 0.7) +
  scale_colour_viridis(name = "Density") +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(
    colour = "firebrick",
    linetype = "dashed",
    slope = 1,
    intercept = 0
  ) +
  labs(
    x = "Over-dispersion\n(with spike-ins)",
    y = "Over-dispersion\n(without spike-ins)"
  ) +
  theme(
    legend.position = "bottom",
    legend.text = element_text(angle = 45, size = 8, hjust = 0.5, vjust = 0.5)
  )
g1 + g2 + plot_annotation(tag_levels = "A")
```

# HVG/LVG detection using BASiCS


The functions `BASiCS_DetectHVG` and `BASiCS_DetectLVG` enable the identification 
of genes with substantially high (HVG) or low (LVG) transcriptional variability 
within a population of cells. 

We label HVGs those genes for which their residual over-dispersion ($\epsilon_i$) 
exceeds a pre-defined threshold with high probability. Similarly, LVGs are those
whose $\epsilon_i$ is below a pre-specified threshold with high probability. 
In both cases, the probability cut-off is chosen using a grid-search that aims 
to match a given expected false discovery rate (EFDR; EFDR=10\% as default) 
[@Newton2004]. Here, we illustrate this using the naive CD4^+^ T cells (with spike-ins)


```{r det-vg-naive, message=TRUE, fig.cap="HVG and LVG detection using BASiCS (naive CD4+ T cells, with spike-ins). For each gene, BASiCS posterior estimates (posterior medians) associated to mean expression and residual over-dispersion parameters are plotted. Genes are coloured according to HVG/LVG status. Genes that are not expressed in at least 2 cells are excluded."}
## Highly variable genes
hvg <- BASiCS_DetectHVG(chain_naive, EpsilonThreshold = log(2))
## Lowly variable genes
lvg <- BASiCS_DetectLVG(chain_naive, EpsilonThreshold = -log(2))

## Merge both tables
vg_table <- merge(
  as.data.frame(hvg, Filter = FALSE),
  as.data.frame(lvg, Filter = FALSE),
  all = TRUE
)

## mark genes as highly variable, lowly variable, or not either.
vg_table$VG <- "Not HVG or LVG"
vg_table$VG [vg_table$HVG] <- "HVG"
vg_table$VG [vg_table$LVG] <- "LVG"
ggplot (vg_table) +
  aes(log10(Mu), Epsilon, colour = VG) +
  geom_point() +
  geom_hline(yintercept = 0, lty = 2) +
  labs(
    x = "BASiCS means (log10)",
    y = "BASiCS residual\nover-dispersion"
    ) +
  scale_colour_manual(name = NULL,
                      values = c(
                        "HVG" = "firebrick",
                        "LVG" = "dodgerblue",
                        "Not HVG or LVG" = "grey80"),
                      na.value = "grey80")
```

For the naive CD4^+^ T cell data, we obtained `r sum(vg_table$VG == "HVG")` HVG 
and `r `sum(vg_table$VG == "LVG")` 380 LVG. As shown in Figure 
\@ref(fig:efdr-plot-vg-naive), these genes are distributed across a wide range 
of mean expression values. As an illustration, Figure 10 shows the distribution 
of normalised expression values for selected HVG and LVG, focusing on examples 
with similar mean expression levels. As expected, HVG tend to exhibit a wider 
distribution and potentially bimodal distribution (Figure \@ref(fig:dc-vg)A). 
Instead, LVG tend to have more narrow and unimodal distributions (Figure \@ref(fig:dc-vg)B).

```{r dc-vg, fig.cap = "Examples of HVG and LVG within naive CD4+T cells"}
library("reshape2")
## Obtain normalised expression values
dc_naive <- BASiCS_DenoisedCounts(sce_naive, chain_naive)
vg_table <- merge(
  as.data.frame(lvg, Filter = FALSE),
  as.data.frame(hvg, Filter = FALSE),
  by = c("GeneName", "GeneIndex", "Mu", "Delta", "Epsilon"),
  suffixes = c("LVG", "HVG")
)
vg_table <- merge(
  vg_table,
  genenames,
  by.x = "GeneName", by.y = "ensembl_gene_id",
  sort = FALSE
)

## Select HVG/LVG genes with similar mean expression values
low_exp <- 2
up_exp <- 3
is_mid_exp <- log10(vg_table$Mu) > low_exp & log10(vg_table$Mu) < up_exp
hvg_table <- vg_table[which(is_mid_exp & vg_table$HVG),]
lvg_table <- vg_table[which(is_mid_exp & vg_table$LVG),]

## Order by epsilon and select top 3 HVG and LVG within the genes selected above
top_hvg <- order(hvg_table$Epsilon, decreasing = TRUE)[1:3]
top_lvg <- order(lvg_table$Epsilon, decreasing = FALSE)[1:3]
hvg_counts <- log10(t(dc_naive[hvg_table$GeneName[top_hvg],]) + 1)
lvg_counts <- log10(t(dc_naive[lvg_table$GeneName[top_lvg],]) + 1)

## Add genenames
colnames(hvg_counts) <- hvg_table$external_gene_name[top_hvg]
colnames(lvg_counts) <- lvg_table$external_gene_name[top_lvg]
plot_params <- list(
  geom_violin(na.rm = TRUE),
  coord_flip(),
  ylim(-0.05, max(log10(dc_naive + 1))),
  geom_jitter(position = position_jitter(0.3)),
  ylab("log10(norm count + 1)"),
  xlab("Gene")
)
plot_hvg <- ggplot(melt(hvg_counts), aes(x = Var2, y = value)) +
  plot_params + ggtitle("Example HVGs")
plot_lvg <- ggplot(melt(lvg_counts), aes(x = Var2, y = value)) +
  plot_params + ggtitle("Example LVGs")
plot_hvg + plot_lvg + plot_annotation(tag_levels = "A")
```

# Differential mean and variability testing using BASiCS

Finally, we perform differential testing to identify genes 
with different expression patterns between naive and stimulated
CD4^+^ T cells. This considers both genes with changes in mean expression and 
those whose transcriptional variability changes between the naive and stimulated
cells. The results are summarised in Fig \@ref{fig:de-cd4}.

```{r de-cd4}
## Perform differential testing
test_de <- BASiCS_TestDE(
  Chain1 = chain_naive,
  Chain2 = chain_active,
  GroupLabel1 = "Naive",
  GroupLabel2 = "Active",
  EFDR_M = 0.1,
  EFDR_R = 0.1,
  MinESS = 100,
  Plot = FALSE,
  PlotOffset = FALSE
)
```

First, we explore the results of the **differential mean expression test**
using MA plots and volcano plots (Figure \@ref{fig:de-cd4-mean}). In this 
instance, it is clear that a large number of genes are differentially expressed 
between the two conditions.

```{r de-cd4-mean, fig.cap = "Upper panel presents the mean-difference plot associated to the differential mean expression test between naive and active cells. Log-fold changes of average expression in naive cells relative to active cells are plotted against average expression estimates combined across both groups of cells. Bottom panel presents the volcano plot associated to the same test. Log-fold changes of average expression in naive cells relative to active cells are plotted against their associated tail posterior probabilities. Colour indicates the differential expression status for each gene, including a label to identify genes that were excluded from differential expression test due to low effective sample size."}
p1 <- BASiCS_PlotDE(test_de, Parameters = "Mean", Plots = "MA")
p2 <- BASiCS_PlotDE(test_de, Parameters = "Mean", Plots = "Volcano")
p1 / p2
```

To facilitate interpretation, we also visualise expression patterns for genes
with differential mean expression patterns. To do this, we calculate normalised 
expression values for each cell and gene, correcting for a global offset between 
naive and activated cells. 

```{r}
offset <- BASiCS_CorrectOffset(chain_naive, chain_active)
offset$Offset
## Get offset corrected chain
chain_naive <- offset$Chain
## Obtain normalised counts within each group of cells
dc_naive <- BASiCS_DenoisedCounts(sce_naive, chain_naive, WithSpikes = FALSE)
dc_active <- BASiCS_DenoisedCounts(sce_active, chain_active, WithSpikes = FALSE)
```

We then use `r Biocpkg("ComplexHeatmap")` to visualise expression patterns for
different groups of genes as defined by the differential mean expression test above.

```{r heatmap-de-mean, fig.cap="Heatmap displays normalised expression values (log10(x + 1) scale) for naive and active cells. Genes are stratified according to their differential expression status (non differentially expressed; upregulated in naive or active cells). For each group, 15 example genes are shown. These were selected according to the ranking of their associated tail posterior probabilities associated to the differential mean expression test. Colour indicates expression level; colour bars on the right of heatmap segments indicate the inferred mean expression level (in log scale) for each gene in each population."}

library("ComplexHeatmap")
library("circlize")
library("RColorBrewer")

## Extract table with diff mean results only
table_de_mean <- as.data.frame(test_de,
                               Parameter = "Mean",
                               Filter = FALSE)

## Add gene symbol to table
table_de_mean$Symbol <- genenames[table_de_mean$GeneName, 2]
## utility function for selecting genes
select_top_n <- function(table, counts, condition, n=15, decreasing=TRUE) {
  ind_condition <- table$ResultDiffMean == condition
  table <- table[ind_condition,]
  ind_diff <- order(table$ProbDiffMean, decreasing = decreasing)[1:n]
  genes <- table$GeneName[ind_diff]
  counts[genes,]
}
## Active & naive count matrices for genes up-regulated in active cells
act_counts_act <- select_top_n(table_de_mean, dc_active, "Active+")
nai_counts_act <- select_top_n(table_de_mean, dc_naive, "Active+")
## Active & naive count matrices for genes up-regulated in naive cells
act_counts_nai <- select_top_n(table_de_mean, dc_active, "Naive+")
nai_counts_nai <- select_top_n(table_de_mean, dc_naive, "Naive+")
## Active & naive count matrices for genes not differentially expressed
act_counts_nde <- select_top_n(table_de_mean, dc_active, "NoDiff",
                               decreasing = FALSE)
nai_counts_nde <- select_top_n(table_de_mean, dc_naive, "NoDiff",
                               decreasing = FALSE)
## Combine count matrices by cell type
counts_active <- rbind(act_counts_act, act_counts_nai, act_counts_nde)
counts_naive <- rbind(nai_counts_act, nai_counts_nai, nai_counts_nde)
## split heatmaps by gene category
split <- data.frame(
  Upregulated = c(
    rep("Up-regulated \nin active", nrow(act_counts_act)),
    rep("Up-regulated \nin naive", nrow(act_counts_nai)),
    rep("Non DE", nrow(act_counts_nde))
    )
)
syms <- genenames[rownames(counts_active), 2]
fontsize <- 7
## Color palettes using circlize
col <- colorRamp2(
  breaks = seq(0,
               log10(max(c(counts_naive, counts_active) + 1)),
               length.out = 20),
  colors = viridis(20)
)
## Subset table of DE results to extract mean estimates
match_order <- match(rownames(counts_naive), table_de_mean$GeneName)
table_de_selected <- table_de_mean[match_order,]
## Color palette for mu annotation
log_mu_naive <- log10(table_de_selected$Mean1)
log_mu_active <- log10(table_de_selected$Mean2)
mu_col <- colorRamp2(
  breaks = seq(0, max(c(log_mu_naive, log_mu_active)), length.out = 20),
  colors = viridis(20, option = "A", direction = 1)
)
Heatmap(
  log10(counts_naive + 1),
  row_labels = syms,
  row_names_gp = gpar(fontsize = fontsize),
  name = "log10(count + 1)",
  column_dend_height = unit(0.2, "npc"),
  column_title_side = "bottom",
  column_title = "Naive cells",
  show_column_names = FALSE,
  cluster_rows = FALSE,
  split = split,
  right_annotation = rowAnnotation(
    log_mu = log_mu_naive,
    col = list(log_mu = mu_col)
    ),
  col = col) +
Heatmap(
  log10(counts_active + 1),
  row_labels = syms,
  column_dend_height = unit(0.2, "npc"),
  row_names_gp = gpar(fontsize = fontsize),
  column_title = "Active cells",
  column_title_side = "bottom",
  show_column_names = FALSE,
  split = split,
  show_heatmap_legend = FALSE,
  right_annotation = rowAnnotation(
    log_mu = log_mu_active,
    col = list(log_mu = mu_col)),
  cluster_rows = FALSE,
  col = col)
```

Finally, a similar analysis is applied to identify genes with 
**differential transcriptional variability patterns**. 

```{r de-cd4-rd, fig.cap="Upper panel presents the mean-difference plot associated to the differential residual over-dispersion test between naive and active cells. Differences of residual over-dispersion in naive cells relative to active cells are plotted against average expression estimates combined across both groups of cells. Bottom panel presents the volcano plot associated to the same test. Differences of residual over-dispersion in naive cells relative to active cells are plotted against their associated tail posterior probabilities. Colour indicates the differential expression status for each gene, including a label to identify genes that were excluded from differential expression test due to low effective sample size."}
p1 <- BASiCS_PlotDE(test_de, Parameters = "ResDisp", Plots = "MA")
p2 <- BASiCS_PlotDE(test_de, Parameters = "ResDisp", Plots = "Volcano")
p1 / p2
```

To better understand these results, we will explore them in tandem with the 
results of the differential mean expression test. As expected, Figure 
\@ref{fig:de-mean-vs-rd} shows that these are independent analyses, given that 
changes in residual over-dispersion are not confounded by changes in mean expression.

```{r de-mean-vs-rd, fig.cap="Difference in residual over-dispersion against log2 fold change in mean expression."}
## Extract table with differential transcriptional variability results
table_de_resdisp <- as.data.frame(test_de,
                                  Parameter = "ResDisp",
                                  Filter = FALSE)
## combine results of differential mean and residual over-dispersion tests
table_de_combined <- merge(table_de_mean, table_de_resdisp)
## merge with some summary statistics about genes
gene_tests <- data.frame(
  "GeneName" = rownames(dc_naive),
  "ExpPropNaive" = rowMeans(dc_naive > 0),
  "ExpPropActive" = rowMeans(dc_active > 0),
  "nExpPropNaive" = rowSums(dc_naive > 0),
  "nExpPropActive" = rowSums(dc_active > 0)
)
table_combined_genes <- merge(table_de_combined, gene_tests)
## create list of generic plot parameters to use across a few plots
plot_params <- list(
  geom_pointdensity(),
  scale_colour_viridis(name = "Density"),
  theme(
    # text = element_text(size = rel(3)),
    legend.position = "bottom",
    legend.text = element_text(angle = 45, size = 8, hjust = 1, vjust = 1),
    legend.key.size = unit(0.018, "npc")))
## plot log2FC against difference of residual over-dispersion
ggplot(table_de_combined) +
  aes(MeanLog2FC, ResDispDistance) +
  plot_params +
  xlim(-15, 15) +
  labs(
    x = "log2 fold change in mean expression",
    y = "Difference in residual over-dispersion"
)
```

While genes with significant changes in residual over-dispersion often have 
similar levels of mean expression, as seen in Figure \@ref{fig:de-rd-patterns}A 
and C, they may have a different proportion of zero counts in the two cell 
populations. Figure \@ref{fig:de-rd-patterns}B and D show that many genes with 
higher residual over-dispersion in naive cells have a lower proportion of zeros 
in active cells, and vice versa.

```{r de-rd-patterns, fig.cap="A, C: log2 change in expression against against log mean expression for genes with higher residual over-dispersion in naive (A) cells and active (D) cells. B, D: Proportion of expressed cells for genes, with higher residual over-dispersion in naive cells (B) and active (D) cells. Dashed red lines in panels A and C represent a log fold change of zero, meaning no change in average expression. Dashed red lines in panels B and D represent the line described by y=x, representing equal detection levels in both populations."}
g1 <- ggplot(table_combined_genes[table_combined_genes$ResultDiffResDisp == "Naive+",]) +
  aes(MeanOverall, MeanLog2FC) +
  plot_params +
  ylim(-15, 15) +
  scale_x_log10() +
  labs(x = "Mean expression", y = "log2 fold change") +
  geom_hline(yintercept = 0, colour = "firebrick", linetype = "dashed")
g2 <- ggplot(table_combined_genes[table_combined_genes$ResultDiffResDisp == "Active+",]) +
  aes(MeanOverall, MeanLog2FC) +
  plot_params +
  ylim(-15, 15) +
  scale_x_log10() +
  labs(x = "Mean expression", y = "log2 fold change") +
  geom_hline(yintercept = 0, colour = "firebrick", linetype = "dashed")
g3 <- ggplot(table_combined_genes[table_combined_genes$ResultDiffResDisp == "Naive+",]) +
  aes(x = ExpPropNaive, y = ExpPropActive) +
  plot_params +
  labs(
    x = "Proportion of cells\nexpressing (naive)",
    y = "Proportion of cells\nexpressing (active)"
    ) +
  geom_abline(slope = 1, intercept = 0, colour = "firebrick", linetype = "dashed")
g4 <- ggplot(table_combined_genes[table_combined_genes$ResultDiffResDisp == "Active+",]) +
  aes(x = ExpPropNaive, y = ExpPropActive) +
  plot_params +
  labs(
    x = "Proportion of cells\nexpressing (naive)",
    y = "Proportion of cells\nexpressing (active)"
    ) +
  geom_abline(slope = 1, intercept = 0, colour = "firebrick", linetype = "dashed")
(g1 + g3) / (g2 + g4) + plot_annotation(tag_levels = "A")
```

# Session info

```{r}
sessionInfo()
```
